dnl This file is part of QMake, Quick Make System
dnl Copyright (C) 2011-16, University of Surrey
dnl This code may be redistributed under the terms of the GNU General
dnl Public License (GPL). See the gpl.licence file for details or
dnl see http://www.gnu.org/copyleft/gpl.html
dnl
dnl file-header-ends-here


  
dnl QM_SET_COMPILER_CCFLAGS
dnl
dnl Macro to declare the flags required to configure the C++ compiler to
dnl operate in a manner usable by QMake.
dnl
dnl No macro parameters
dnl
dnl Global variables used:
dnl
dnl       AWK                        Contains the path to the Awk utility.
dnl                                  Can initially be primed by the user to
dnl                                  force the use of a particular program.
dnl                                  Regarded as a key tool as it is used
dnl                                  by configure itself.
dnl       COMPILER_ANSI_CCFLAGS    } { Receive the compiler specific flags
dnl       COMPILER_DEBUG_CCFLAGS   } { for setting the appropriate mode of
dnl       COMPILER_GPROF_CCFLAGS   } { compiler operation required by QMake.
dnl       COMPILER_NON_OPT_CCFLAGS } {  .._ANSI_.. is used for compiling
dnl       COMPILER_OPT_CCFLAGS     } { ANSI-C++ source code; .._DEBUG_.. to
dnl       COMPILER_PROF_CCFLAGS    } { include debug info; .._GPROF_.. for
dnl       COMPILER_SHARED_CCFLAGS  } { compiling code that can be analysed
dnl                                  { by the gprof utility (.._PROF_.. by
dnl                                  { the prof utility) and .._SHARED_..
dnl                                  { to compiled shared objects. With the
dnl                                  { exception of the .._NON_OPT_.. flag,
dnl                                  { all of these flags drive the default
dnl                                  { value of the appropriately named
dnl                                  { PKG_... flag (which is the actual
dnl                                  { variable used in the QMake makefiles).
dnl                                  { .._NON_OPT_.. is appended to the
dnl                                  { PKG_DEFAULT... flags used for the
dnl                                  { non-optimised builds. All of these
dnl                                  { variables are primed based on the
dnl                                  { compiler in use and declare the
dnl                                  { variable for output to the config.X
dnl                                  { configuration file.
dnl       COMPILER_SPECIFIC_CCFLAGS  Receive any compiler specific flags
dnl                                  required to configure the C++ compiler
dnl                                  to work with QMake. Unlike the above
dnl                                  variables, this value is used on every
dnl                                  compilation via the PKG_GLOBAL_CCFLAGS
dnl                                  makefile variable. This variable is set
dnl                                  based on the compiler in use and is
dnl                                  declared to output to the config.X
dnl                                  configuration file.
dnl       CONFIGURE_CCFLAGS          Not actually modified or interrogated
dnl                                  by this macro; merely declared for 
dnl                                  output substitution into the configure
dnl                                  settings file. Holds any user-supplied
dnl                                  CCFLAGS, originally primed in the macro
dnl                                  QM_LOCATE_KEY_TOOLS.
dnl       CXX                        Holds the path to the C++ compiler in
dnl                                  use. May be updated to include extra
dnl                                  global compiler options.
dnl       CXX_VERSION              } { Receives the version information for
dnl       CXX_MAJOR                } { the current C++ compiler.
dnl       CXX_MINOR                }
dnl       GXX                        Flag, originally set by AC_PROG_CXX
dnl                                  indicating if a GNU C++ compiler is in
dnl                                  use. Set to yes for a GNU compiler.
dnl       NVCC_ANSI_NVCCFLAGS     } { Receive the appropriate compiler flags
dnl       NVCC_DEBUG_NVCCFLAGS    } { for compiling CUDA code in combination
dnl       NVCC_GPROF_NVCCFLAGS    } { with the current C++ compiler. Setting
dnl       NVCC_NON_OPT_NVCCFLAGS  } { for each variable is from the sister
dnl       NVCC_OPT_NVCCFLAGS      } { COMPILER_xxx_CCFLAGS variable with any
dnl       NVCC_PROF_NVCCFLAGS     } { flags that the CUDA compiler driver
dnl       NVCC_SHARED_NVCCFLAGS   } { cannot cope with being prefixed with
dnl       NVCC_SPECIFIC_NVCCFLAGS } { a -Xcompiler directive. This macro
dnl                                 { declares all of these variables for
dnl                                 { output to the configuration files.
dnl
AC_DEFUN([QM_SET_COMPILER_CCFLAGS],
         [trace 2 Set compiler specific CCFLAGS

          dnl# First declare that this macro should never be called after
          dnl# QM_PROCESS_EXTLIBS (for QMake project configure programs, this
          dnl# macro need not be called (if the configure does not alter the
          dnl# compiler settings) so the relationship is not an AC_REQUIRE in
          dnl# QM_PROCESS_EXTLIBS).
          AC_BEFORE([QM_SET_COMPILER_CCFLAGS],[QM_PROCESS_EXTLIBS])

          dnl# Additionally, this macro should never be called unless
          dnl# QM_LOCATE_KEY_TOOLS has already been called.
          AC_REQUIRE([QM_LOCATE_KEY_TOOLS])
          
          if ( test x$GXX = xyes )
          then
             trace 3 We have a GNU C++ Compiler
              # Or something masquerading as one (e.g. CLang)

             COMPILER_ANSI_CCFLAGS=" -ansi "
             NVCC_ANSI_NVCCFLAGS=" -Xcompiler -ansi "
             # -ansi is not recognised by the CUDA compiler driver. This means
             # we need to prefix them with the -Xcompiler switch that causes
             # nvcc to ignore the following flag but still pass it on to any
             # subsequent GNU compilation.

             COMPILER_DEBUG_CCFLAGS=" -g "
             NVCC_DEBUG_NVCCFLAGS=$COMPILER_DEBUG_CCFLAGS

             COMPILER_GPROF_CCFLAGS=" -pg "
             NVCC_GPROF_NVCCFLAGS=$COMPILER_GPROF_CCFLAGS

             COMPILER_NON_OPT_CCFLAGS=" -fno-math-errno "
             #
             # We really treat non-optimised builds as a low optimised version.
             # We therefore need to consider the compiler version as for the
             # full optimised flags (see below).
             #
             # While using fno-math-errno breaks full standards compliance, it
             # is used to give us a consistent environment across platforms as
             # the math library on OSX never actually sets errno anyway. There
             # is no point in setting this switch globally (i.e. in {C}CFLAGS
             # rather than _OPT_C{C}FLAGS) as it is not actually used by g++
             # if we are not performing an optimised compile.

             NVCC_NON_OPT_NVCCFLAGS=" -Xcompiler -fno-math-errno "
             #
             # The CUDA compiler driver does not understand the -fno-math-errno
             # switch. This means we need to prefix it with the -Xcompiler 
             # switch that causes nvcc to ignore the following flag but still
             # pass it on to any subsequent GNU compilation.

             COMPILER_OPT_CCFLAGS=" -O2 -fno-math-errno "
             #
             # Again, the caveat from the non-optimised flags applies to the
             # use of fno-math-errno (see above).

             NVCC_OPT_NVCCFLAGS=" -O2 -Xcompiler -fno-math-errno "
             #
             # Likewise, we need the -Xcompiler prefix on -fno-math-errno

             # strict-aliasing enabled by optimised builds has been known to
             # sometimes cause g++ 4.x (x<7) to produce incorrect code (even
             # where the aliasing rules are followed). So we turn it off...
             dnl Using @S|@ glyph to prevent expansion of $1/2/3 as macro arg
             CXX_VERSION=`$CXX -v 2>&1 | $GREP 'gcc version' | $AWK '{ print @S|@3 }'`
             CXX_MAJOR=`echo $CXX_VERSION | $AWK -F. '{ print @S|@1 }'`
             CXX_MINOR=`echo $CXX_VERSION | $AWK -F. '{ print @S|@2 }'`
             if ( test X$CXX_MAJOR = X4 )
             then
                if (( test X$CXX_MINOR != X ) && ( test $CXX_MINOR -gt 6 ))
                then
                   trace 5 We have a version of g++ 4.x without the aliasing bug
                   trace 6 g++ version $CXX_MAJOR.$CXX_MINOR
                else
                   trace 5 We potentially have the aliasing bug in our g++ compiler
                   trace 6 g++ version $CXX_MAJOR.$CXX_MINOR
                   COMPILER_NON_OPT_CCFLAGS=" "$COMPILER_NON_OPT_CCFLAGS" -fno-strict-aliasing "
                   NVCC_NON_OPT_NVCCFLAGS=" "$NVCC_NON_OPT_NVCCFLAGS" -Xcompiler -fno-strict-aliasing "
                   # CUDA compiler driver does not recognise the -fno-strict-aliasing
                   # switch so we have to use the -Xcompiler switch to tell the
                   # driver to ignore the following option.
                   COMPILER_OPT_CCFLAGS=" "$COMPILER_OPT_CCFLAGS" -fno-strict-aliasing "
                   NVCC_OPT_NVCCFLAGS=" "$NVCC_OPT_NVCCFLAGS" -Xcompiler -fno-strict-aliasing "
                   # Again we need to get the compiler driver to ignore the switch.
                fi
             else
                trace 5 We are using g++ but not version 4.x
             fi

             COMPILER_PROF_CCFLAGS=" -p "
             NVCC_PROF_NVCCFLAGS=$COMPILER_PROF_CCFLAGS

             COMPILER_SHARED_CCFLAGS=" -shared -fPIC "
             NVCC_SHARED_NVCCFLAGS=" -shared -Xcompiler -fPIC "
             # Prefix -fPIC as the CUDA compiler driver cannot cope with it.

             COMPILER_SPECIFIC_CCFLAGS=" -Wall -pipe -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE "
             NVCC_SPECIFIC_NVCCFLAGS=" -Xcompiler -Wall -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE "
             # As nvcc chokes on -Wall we prefix it with the nvcc -Xcompiler 
             # "ignore this" switch. The warnings may or may not be useful
             # as some of the code compiled will be generated code. Given
             # nvcc fails to understand -pipe, we drop this switch in case
             # it causes any communication issues between the CUDA compiler
             # driver and the child GNU compilation.
          else
              trace 3 We do not have a GNU C++ compiler
              # Try relevant machine specific options we have used before
              # 
              # N.B.
              #      As CUDA expects the available compiler to be the GNU
              #      version, not having a GNU compiler effectively blocks
              #      CUDA support. For this reason, we have no need to set
              #      NVCCFLAGS in this block.
              # 
             dnl 
             dnl Although testing the host OS, we are using that to identify the native
             dnl tool set that may be in use. These are not platform specific settings
             dnl per se. DO NOT PUT PLATFORM SPECIFIC SETTINGS HERE. This section is for
             dnl settings that relate to specific tool sets. They may or may not relate
             dnl to specific platforms but that is coincidental. Platform specific
             dnl settings must go in the section at the end of this script. If you have a
             dnl specific compiler on a platform, put its settings here. If you have
             dnl specific settings for a common tool (say the GNU compilers) when run on
             dnl a particular platform, put those settings at the end of this script.
             dnl 
             case X$host_os in
              Xirix* )    trace 3 Setting CCFLAGS we have previously used under Irix
                          CXX=$CXX" -n32 -J4 -mp -LANG:ansi-for-init-scope=on "
                          # Not sure why this originally was done this way rather than
                          # use CCFLAGS, but assume there was a reason and propagate the
                          # method
                          COMPILER_ANSI_CCFLAGS=" -ansi "
                          COMPILER_DEBUG_CCFLAGS=""
                          COMPILER_GPROF_CCFLAGS=""
                          COMPILER_NON_OPT_CCFLAGS=""
                          COMPILER_OPT_CCFLAGS=" -O3 -OPT:condt_copy_limit=50000:Olimit=80000 "
                          COMPILER_PROF_CCFLAGS=""
                          COMPILER_SHARED_CCFLAGS=""
                          COMPILER_SPECIFIC_CCFLAGS=" -mips4 -r1000 -woff 1021 -woff 1681 -woff 1882 "
                          # -woff switches possibly in response to Ravl code rather
                          # than being generically necessary for QMake
                          ;;
              Xsolaris* ) trace 3 Setting CCFLAGS we have previously used on Solaris
                          COMPILER_ANSI_CCFLAGS=" -ansi "
                          COMPILER_DEBUG_CCFLAGS=""
                          COMPILER_GPROF_CCFLAGS=" -pg "
                          COMPILER_NON_OPT_CCFLAGS=""
                          COMPILER_OPT_CCFLAGS=" -O2 "
                          COMPILER_PROF_CCFLAGS=" -p "
                          COMPILER_SHARED_CCFLAGS=" -KPIC "
                          COMPILER_SPECIFIC_CCFLAGS=""
                          ;;
              * )         trace 3 Setting default CCFLAGS
                          COMPILER_ANSI_CCFLAGS=" -ansi "
                          COMPILER_DEBUG_CCFLAGS=""
                          COMPILER_GPROF_CCFLAGS=""
                          COMPILER_NON_OPT_CCFLAGS=""
                          COMPILER_OPT_CCFLAGS=" -O2 "
                          COMPILER_PROF_CCFLAGS=""
                          COMPILER_SHARED_CCFLAGS=""
                          COMPILER_SPECIFIC_CCFLAGS=""
                          ;;
             esac
          fi
          # Allow C++ compiler switches to be written to Config.QMake
          
          # Allow output of any user provided CCFLAGS
          AC_SUBST([CONFIGURE_CCFLAGS])
          # any user-provided CCFLAGS will be recorded in Config.QMake as QMAKE_CCFLAGS

          # Allow output of compiler specific settings
          AC_SUBST([COMPILER_ANSI_CCFLAGS])
          AC_SUBST([COMPILER_DEBUG_CCFLAGS])
          AC_SUBST([COMPILER_GPROF_CCFLAGS])
          AC_SUBST([COMPILER_NON_OPT_CCFLAGS])
          AC_SUBST([COMPILER_OPT_CCFLAGS])
          AC_SUBST([COMPILER_PROF_CCFLAGS])
          AC_SUBST([COMPILER_SHARED_CCFLAGS])
          AC_SUBST([COMPILER_SPECIFIC_CCFLAGS])

          dnl Allow output of CUDA compiler specific settings
          dnl Note: These will be null if we do not have a GNU C++ compiler
          dnl       at that is a pre-requisite of CUDA support.
          AC_SUBST([NVCC_ANSI_NVCCFLAGS])
          AC_SUBST([NVCC_DEBUG_NVCCFLAGS])
          AC_SUBST([NVCC_GPROF_NVCCFLAGS])
          AC_SUBST([NVCC_NON_OPT_NVCCFLAGS])
          AC_SUBST([NVCC_OPT_NVCCFLAGS])
          AC_SUBST([NVCC_PROF_NVCCFLAGS])
          AC_SUBST([NVCC_SHARED_NVCCFLAGS])
          AC_SUBST([NVCC_SPECIFIC_NVCCFLAGS])
         ]
        )
