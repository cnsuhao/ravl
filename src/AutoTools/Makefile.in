# @configure_input@
# This file is part of RAVL, Recognition And Vision Library
# Copyright (C) 2011-14, University of Surrey
# This code may be redistributed under the terms of the GNU General
# Public License (GPL). See the gpl.licence file for details or
# see http://www.gnu.org/copyleft/gpl.html

SOURCEHOME=@abs_srcdir@/src

PROJECT_OUT=@abs_builddir@

WORKING_QMAKE_DATA=@WORKING_QMAKE_DATA@
WORKING_QMAKE_BIN=@WORKING_QMAKE_BIN@

# Ensure any DESTDIR is an absolute path
ifdef DESTDIR
  ABS_DESTDIR=$(abspath $(DESTDIR))

  # Propogate absolute path going forward
  SET_DESTDIR=DESTDIR=$(ABS_DESTDIR)
endif

# Include QMake global definitions
include @QMAKE_CONFIGFILES@/Config.QMake

# Include project specific definitions
include $(PROJECT_OUT)/Config.Project

# Include project specific installation targets
include $(PROJECT_OUT)/Targets.Project

# RAVL Makefile and default flags for QMake and RAVL itself

RAVL_MAKEFILE=$(WORKING_QMAKE_DATA)/Makefiles/QMake.mk

RAVL_FLAGS=BASEINSTALL=1 FULLBUILDSRC='BASE_VAR=none' \
           CONFIGFILE=$(PROJECT_OUT)/Config.Project \
           INCLUDEDIR=$(PROJECT_OUT)/include 

ifndef USE_INSTALLED_PATHS
  USE_INSTALLED_PATHS=N
endif

# Trace commands if QMAKE_INFO is in use
ifndef QMAKE_INFO
SHOWIT=@
else
SHOWIT=
endif

# Control version stamping of single-shared library
ifndef STAMP_SINGLE
 ifdef LIB_STAMP
  STAMP_SINGLE=$(LIB_STAMP)
 else
  STAMP_SINGLE=VER
  # Default to full version stamping
 endif
endif

ifeq ($(STAMP_SINGLE),VER)
 STAMP_SINGLE_EXT=.$(SHAREDEXT).$(PROJECT_VERSION)
else
 ifeq ($(STAMP_SINGLE),NO)
  # Version stamping switched off
  STAMP_SINGLE_EXT=.$(SHAREDEXT)
 else
  STAMP_SINGLE_EXT=.$(SHAREDEXT).$(PROJECT_MAJOR)
 endif
endif

# Additional files to manually copy into a distribution
#
# These need manual specification as they do not always appear in the
# SOURCES/HEADERS definitions as they are included dependant on RESOURCES
#
DIST_ADDITIONS=src/GUI/3D/gdkgl.c src/GUI/3D/gtkglarea.c \
               src/GUI/3D/gdkgl.h src/GUI/3D/gtkglarea.h

# Builds

default: qmake fullsrc singleoptsharedbin pkgconf

check: testsingleoptshared 

debug: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=debug NOEXEBUILD=1 \
	        $(if $(filter-out 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                     PATH_DEFINITIONS="$(INSTALLED_PATHS)" \
                 ) \
                libbuild

debugshared: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=debug SHAREDBUILD=1 NOEXEBUILD=1 \
	        $(if $(filter-out 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                     PATH_DEFINITIONS="$(INSTALLED_PATHS)" \
                 ) \
                libbuild

debugsharedobj: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=debug SHAREDBUILD=1 NOEXEBUILD=1 LINK_PLIB=0 \
	        $(if $(filter-out 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                     PATH_DEFINITIONS="$(INSTALLED_PATHS)" \
                 ) \
                libbuild

dist:
	$(MAKE) -C @abs_srcdir@ \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Dist.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                DIST_ADDITIONS="$(DIST_ADDITIONS)" \
                dist

doc: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/.. \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                LLP="LD_LIBRARY_PATH=$(PROJECT_OUT)/lib/$(ARC)/opt/shared/single:$$LD_LIBRARY_PATH" \
                LOCAL_TEMPLATES="$(PROJECT_OUT)/share/CxxDoc" \
                fulldoc
	cp $(PROJECT_OUT)/share/QMake/Support/Help.txt \
                $(PROJECT_OUT)/share/doc/Ravl/html/Help.txt
#       We currently start from above the src directory ($SOURCEHOME)/..) in
#       order to pick up the documentation from QMake. This is because there is
#       currently no framework to link to documentation from another project.
#       This means we cannot produce the QMake documentation from within that
#       seperate project and link to that from the Ravl documentation. We
#       therefore have to treat the QMake documentation as if it was part Ravl,
#       hence the start point.
#
#       Final step copies across the QMake help file; this is again due to there
#       being no existing mechanism to link to documentation in an external
#       project.

fullsrc: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) NOCHECKOUT=1 \
	        $(if $(filter-out 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                     PATH_DEFINITIONS="$(INSTALLED_PATHS)" \
                 ) \
                fullsrc

gprof: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=gprof NOEXEBUILD=1 \
                libbuild

gprofbin: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                fullgprof

gprofshared: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=gprof SHAREDBUILD=1 NOEXEBUILD=1 \
                libbuild

gprofsharedobj: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=gprof SHAREDBUILD=1 NOEXEBUILD=1 LINK_PLIB=0 \
                libbuild

gprofsharedbin: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) SHAREDBUILD=1 \
                fullgprof

install: installQMake installProject

installProject: installsingleoptshared installHdrs installpkgconf installRavlDefs

install-strip:
	$(MAKE) STRIP_SWITCH="-s" install

install-stripProject:
	$(MAKE) STRIP_SWITCH="-s" installProject


# Dot Def file installation.
#
# In order to allow existing client projects to easily switch to using the
# single library, Ravl has to install both the dot def file associated with
# the single library and the dot def files associated with all of the Ravl
# "multi" libraries; even if not installing the "multi" libs themselves .
installRavlDefs: installRavl.def installRavlMultiDefs

installRavlMultiDefs:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=debug SHAREDBUILD=1 STRIP_SWITCH=$(STRIP_SWITCH) PROJECT_DIR=Ravl \
                insDefs recurse

installRavl.def: $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/Ravl.def

$(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/Ravl.def: \
                                          $(PROJECT_OUT)/lib/libdep/4install/Ravl.def \
                                          $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep
	$(INSTALL) $(PROJECT_OUT)/lib/libdep/4install/Ravl.def \
                   $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/Ravl.def

$(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep:
	$(SHOWIT)$(MKDIR_P) $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep
 
$(PROJECT_OUT)/lib/libdep/4install/Ravl.def: $(PROJECT_OUT)/lib/libdep/4install/Ravl.def.in
	$(SHOWIT)$(SED) -e 's![@]PROJECT_LIBDIR[@]!$(libdir)!g' \
                        -e 's![@]PROJECT_INCDIR[@]!$(includedir)!g' \
                        $(PROJECT_OUT)/lib/libdep/4install/Ravl.def.in \
                                                > $(PROJECT_OUT)/lib/libdep/4install/Ravl.def
# The installed copy of Ravl.def needs to know the actual values for $libdir
# and $includedir. Hence we only finalise the file when we perform the install. 


# All the install targets recurse down the source directories using the defs.mk
# files to determine what needs installing. The relevant files are then
# installed from their built location in the build tree.

installdebuglib:
	$(if $(filter 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        VAR=debug \
                        SetRootInstalled \
         )
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=debug STRIP_SWITCH=$(STRIP_SWITCH) \
                insLibs recurse
	$(if $(filter 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        VAR=debug \
                        SetRootStaged \
         )
#       + If we are using local (PROJECT_OUT) hard-coded paths in the built
#       binaries (i.e. --disable-fast-install is in use) we first have to
#       rebuild the libraries to reflect the installed location (i.e. $prefix,
#       $datadir, etc.).
#       + Use QMake to install the libraries (this will automatically install the
#       libraries to the $(DESTDIR)$(libdir)/debug/$(libdir) directory.
#       + Finally, if we are using local paths, we need to re-build the relevant
#       objects and libraries with the original path to the staging area.

installdebugsharedlib:
	$(if $(filter 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        VAR=debug SHAREDBUILD=1 \
                        SetRootInstalled \
         )
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=debug SHAREDBUILD=1 STRIP_SWITCH=$(STRIP_SWITCH) \
                insLibs recurse
	$(if $(filter 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        VAR=debug SHAREDBUILD=1 \
                        SetRootStaged \
         )
#       + If we are using local (PROJECT_OUT) hard-coded paths in the built
#       binaries (i.e. --disable-fast-install is in use) we first have to
#       rebuild the libraries to reflect the installed location (i.e. $prefix,
#       $datadir, etc.).
#       + Use QMake to install the libraries (this will automatically install the
#       libraries to the $(DESTDIR)$(libdir)/debug/$(libdir) directory.
#       + Finally, if we are using local paths, we need to re-build the relevant
#       objects and libraries with the original path to the staging area.

installHdrs:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                insHdrs recurse

installopt:
	$(if $(filter 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        VAR=opt \
                        SetRootInstalled \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                       -f $(PROJECT_OUT)/Makefile \
                       optbin \
         )
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) \
                install recurse
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) \
                insLibs recurse
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) \
                insMustLinks recurse
	$(if $(filter 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        VAR=opt \
                        SetRootStaged \
	        $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        optbin \
         )
#       + If we are using local (PROJECT_OUT) hard-coded paths in the built
#       binaries (i.e. --disable-fast-install is in use) we first have to
#       rebuild the libraries to reflect the installed location (i.e. $prefix,
#       $datadir, etc.). We also need to re-make the executables to pick up the
#       path changes.
#       + Use the 'install' function of QMake to install the Ravl utility
#       binaries; config files; data files and scripts. 
#       + Install the libraries via the QMake insLibs
#       + Install the MUSTLINK files via the QMake insMustLinks target.
#       + Finally, if we are using local paths, we need to re-build the relevant
#       objects and libraries with the original path to the staging area and
#       then remake the executables to pick up the restore.
#
#       N.B. This recepie includes a duplication of parts of the installoptlib
#       recepie (we can not use the XXXgeneral XXXlib form used by the shared
#       recepies because of the possible need to rebuild the executables to pick
#       up the change in resource-root). Please remember to apply any changes to
#       the other copy of the code as appropriate.

installoptlib:
	$(if $(filter 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        VAR=opt \
                        SetRootInstalled \
         )
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) \
                insLibs recurse
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) \
                insMustLinks recurse
	$(if $(filter 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        VAR=opt \
                        SetRootStaged \
         )
#       + If we are using local (PROJECT_OUT) hard-coded paths in the built
#       binaries (i.e. --disable-fast-install is in use) we first have to
#       rebuild the libraries to reflect the installed location (i.e. $prefix,
#       $datadir, etc.).
#       + Install the libraries via the QMake insLibs
#       + Install the MUSTLINK files via the QMake insMustLinks target.
#       + Finally, if we are using local paths, we need to re-build the relevant
#       objects and libraries with the original path to the staging area.
#
#       N.B. Parts of this recepie are duplicated in the installopt recepie
#       (we can not use the XXXgeneral XXXlib form used by the shared recepies
#       because of the possible need for installopt to rebuild the executables
#       to pick up the change in resource-root). Please remember to apply any
#       changes to the other copy of the code as appropriate.

installoptshared: installoptsharedgeneral installoptsharedlib

installoptsharedgeneral:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt SHAREDBUILD=1 STRIP_SWITCH=$(STRIP_SWITCH) \
                install recurse
#       Use the 'install' function of QMake to install the Ravl utility
#       binaries; config files; data files and scripts. 

installoptsharedlib:
	$(if $(filter 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        VAR=opt SHAREDBUILD=1 \
                        SetRootInstalled \
         )
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt SHAREDBUILD=1 STRIP_SWITCH=$(STRIP_SWITCH) \
                insLibs recurse
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt SHAREDBUILD=1 STRIP_SWITCH=$(STRIP_SWITCH) \
                insMustLinks recurse
	$(if $(filter 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        VAR=opt SHAREDBUILD=1 \
                        SetRootStaged \
         )
#       + If we are using local (PROJECT_OUT) hard-coded paths in the built
#       binaries (i.e. --disable-fast-install is in use) we first have to
#       rebuild the libraries to reflect the installed location (i.e. $prefix,
#       $datadir, etc.).
#       + Install the libraries via QMake
#       + Install the MUSTLINK objects (the MUSTLINKs are not strictly necessary
#       for the shared library, but may be needed for old client projects that
#       have existing .def files that still include the MUSTLINKs regardless of
#       if a build is shared or not).
#       + Finally, if we are using local paths, we need to re-build the relevant
#       objects and libraries with the original path to the staging area.

installpkgconf: $(ABS_DESTDIR)$(libdir)/pkgconfig $(ABS_DESTDIR)$(libdir)/pkgconfig/Ravl.pc

$(ABS_DESTDIR)$(libdir)/pkgconfig:
	$(SHOWIT)$(MKDIR_P) $(ABS_DESTDIR)$(libdir)/pkgconfig

$(ABS_DESTDIR)$(libdir)/pkgconfig/Ravl.pc: $(PROJECT_OUT)/lib/pkgconfig/4install/Ravl.pc
	$(INSTALL_DATA) $(PROJECT_OUT)/lib/pkgconfig/4install/Ravl.pc \
                        $(ABS_DESTDIR)$(libdir)/pkgconfig/Ravl.pc

$(PROJECT_OUT)/lib/pkgconfig/4install/Ravl.pc: $(PROJECT_OUT)/lib/pkgconfig/4install/Ravl.pc.in
	$(SHOWIT)$(SED) -e 's![@]PROJECT_PREFIX[@]!$(prefix)!g' \
                        -e 's![@]PROJECT_DATAROOTDIR[@]!$(datarootdir)!g' \
                        -e 's![@]PROJECT_DATADIR[@]!$(datadir)!g' \
                        -e 's![@]PROJECT_SYSCONFDIR[@]!$(sysconfdir)!g' \
                        -e 's![@]PROJECT_INCDIR[@]!$(includedir)!g' \
                        -e 's![@]PROJECT_LIBDIR[@]!$(libdir))!g' \
                        $(PROJECT_OUT)/lib/pkgconfig/4install/Ravl.pc.in \
                                             > $(PROJECT_OUT)/lib/pkgconfig/4install/Ravl.pc
# The installed copy of Ravl.pc needs to know the actual values for $libdir
# and $prefix, etc. Hence we only finalise the file when we perform the install. 

installsingledebuglib:
	$(if $(filter 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        VAR=debug LINK_PLIB=0 \
                        singleSetRootInstalled \
         )
	$(SHOWIT)if [ ! -d $(ABS_DESTDIR)$(libdir)/debug$(libdir) ] ;\
                 then \
                     $(MKDIR_P) $(ABS_DESTDIR)$(libdir)/debug$(libdir) ; \
                 fi
	$(INSTALL) $(STRIP_SWITCH) \
                   $(PROJECT_OUT)/lib/$(ARC)/debug/single/libRavl.a \
                   $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.a
	$(if $(filter 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        VAR=debug LINK_PLIB=0 \
                        singleSetRootStaged \
         )
#       + If we are using local (PROJECT_OUT) hard-coded paths in the built
#       binaries (i.e. --disable-fast-install is in use) we first have to
#       rebuild the libraries to reflect the installed location (i.e. $prefix,
#       $datadir, etc.).
#       + Ensure the target dir exists (debug libraries are installed under the
#       same path as the non-debug version but prefixed by any $(DESTDIR) and
#       $(libdir)/debug).
#       + Copy across the single library
#       + Finally, if we are using local paths, we need to re-build the relevant
#       objects and libraries with the original path to the staging area.

installsingledebugsharedlib:
	$(if $(filter 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        VAR=debug SHAREDBUILD=1 LINK_PLIB=0 \
                        singlesharedSetRootInstalled \
         )
	$(SHOWIT)if [ ! -d $(ABS_DESTDIR)$(libdir)/debug$(libdir) ] ; \
                 then \
                     $(MKDIR_P) $(ABS_DESTDIR)$(libdir)/debug$(libdir) ; \
                 fi
	$(INSTALL) $(STRIP_SWITCH) \
                   $(PROJECT_OUT)/lib/$(ARC)/debug/shared/single/libRavl$(STAMP_SINGLE_EXT) \
                   $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl$(STAMP_SINGLE_EXT)
ifeq ($(STAMP_SINGLE),VER)
	$(SHOWIT)if [ -h $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ] || \
                    [ -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ] ; \
                 then \
                    $(RM) $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ; \
                 fi ; \
                 cd $(ABS_DESTDIR)$(libdir)/debug$(libdir); \
                 $(LN_S) libRavl$(STAMP_SINGLE_EXT) libRavl.$(SHAREDEXT).$(PROJECT_MAJOR)
endif
ifneq ($(STAMP_SINGLE),NO)
	$(SHOWIT)if [ -h $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT) ] || \
                    [ -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT) ] ; \
                 then \
                    $(RM) $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT) ; \
                 fi ; \
                 cd $(ABS_DESTDIR)$(libdir)/debug$(libdir); \
                 $(LN_S) libRavl$(STAMP_SINGLE_EXT) libRavl.$(SHAREDEXT)
endif
	$(if $(filter 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        VAR=debug SHAREDBUILD=1 LINK_PLIB=0 \
                        singlesharedSetRootStaged \
         )
#       + If we are using local (PROJECT_OUT) hard-coded paths in the built
#       binaries (i.e. --disable-fast-install is in use) we first have to
#       rebuild the libraries to reflect the installed location (i.e. $prefix,
#       $datadir, etc.).
#       + Ensure the target dir exists (debug libraries are installed under the
#       same path as the non-debug version but prefixed by any $(DESTDIR) and
#       $(libdir)/debug).
#       + Rather than call the insLibs make target, we manually install the
#       library and set up the symbolic links for the less-quantified library
#       names.
#       + Finally, if we are using local paths, we need to re-build the relevant
#       objects and libraries with the original path to the staging area.

installsingleopt:
	$(if $(filter 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        VAR=opt LINK_PLIB=0 \
                        singleSetRootInstalled \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        singleoptbin \
         )
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt SHARED_LIB_POSTFIX=/single STRIP_SWITCH=$(STRIP_SWITCH) \
                install recurse
	$(SHOWIT)if [ ! -d $(ABS_DESTDIR)$(libdir) ] ; \
                 then \
                    $(MKDIR_P) $(ABS_DESTDIR)$(libdir) ; \
                 fi
	$(INSTALL) $(STRIP_SWITCH) \
                   $(PROJECT_OUT)/lib/$(ARC)/opt/single/libRavl.a \
                   $(ABS_DESTDIR)$(libdir)/libRavl.a
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) \
                insMustLinks recurse
	$(if $(filter 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        VAR=opt LINK_PLIB=0 \
                        singleSetRootStaged \
       	        $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        singleoptbin \
         )
#       + If we are using local (PROJECT_OUT) hard-coded paths in the built
#       binaries (i.e. --disable-fast-install is in use) we first have to
#       rebuild the libraries to reflect the installed location (i.e. $prefix,
#       $datadir, etc.). We also need to re-make the executables to pick up the
#       path changes.
#       + We can then use the 'install' function of QMake to install these
#       binaries along with the Ravl config files; data files and scripts. We
#       must set SHARED_LIB_POSTFIX (to /single) in order to force QMake to use
#       the version of the binaries compiled against the single static Ravl
#       library rather than the more usual (for QMake) individual static
#       libraries. 
#       + Rather than call the insLibs make target, we manually copy across the
#       single library having first ensured the target directory exists.
#       + We then install the MUSTLINK files.
#       + Finally, if we are using local paths, we need to re-build the relevant
#       objects and libraries with the original path to the staging area and
#       then remake the executables to pick up the restore.
#
#       N.B. This recepie includes a duplication of parts of the recepie for
#       installsingleoptlib (we can not use the XXXgeneral XXXlib form used by
#       the shared recepies because of the possible need to rebuild the
#       executables to pick up the change in resource-root). Please remember to
#       apply any changes to the other copy of the code as appropriate.

installsingleoptlib:
	$(if $(filter 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        VAR=opt LINK_PLIB=0 \
                        singleSetRootInstalled \
         )
	$(SHOWIT)if [ ! -d $(ABS_DESTDIR)$(libdir) ] ; \
                 then \
                    $(MKDIR_P) $(ABS_DESTDIR)$(libdir) ; \
                 fi
	$(INSTALL) $(STRIP_SWITCH) \
                   $(PROJECT_OUT)/lib/$(ARC)/opt/single/libRavl.a \
                   $(ABS_DESTDIR)$(libdir)/libRavl.a
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) \
                insMustLinks recurse
	$(if $(filter 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        VAR=opt LINK_PLIB=0 \
                        singleSetRootStaged \
         )
#       + If we are using local (PROJECT_OUT) hard-coded paths in the built
#       binaries (i.e. --disable-fast-install is in use) we first have to
#       rebuild the libraries to reflect the installed location (i.e. $prefix,
#       $datadir, etc.).
#       + Ensure the target dir exists
#       + Copy across the library.
#       + We then install the MUSTLINK files.
#       + Finally, if we are using local paths, we need to re-build the relevant
#       objects and libraries with the original path to the staging area.
#
#       N.B. Parts of this recepie are duplicated in the installsingleopt
#       recepie (we can not use the XXXgeneral XXXlib form used by the shared
#       recepies because of the possible need for installsingleopt to rebuild
#       the executables to pick up the change in resource-root). Please
#       remember to apply any changes to the other copy of the code as
#       appropriate.

installsingleoptshared:installsingleoptsharedgeneral installsingleoptsharedlib

installsingleoptsharedgeneral:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt SUMMARIES=Ravl SHAREDBUILD=1 STRIP_SWITCH=$(STRIP_SWITCH) \
                install recurse
#       Use the 'install' function of QMake to install the Ravl utility
#       binaries; config files; data files and scripts. Setting SUMMARIES to
#       Ravl forces QMake to use the version of the binaries compiled against
#       the single shared Ravl library rather than the more usual (for QMake)
#       individual shared libraries. 

installsingleoptsharedlib:
	$(if $(filter 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        VAR=opt SHAREDBUILD=1 LINK_PLIB=0 \
                        singlesharedSetRootInstalled \
         )
	$(SHOWIT)if [ ! -d $(ABS_DESTDIR)$(libdir) ] ; \
                 then \
                    $(MKDIR_P) $(ABS_DESTDIR)$(libdir) ; \
                 fi
	$(INSTALL) $(STRIP_SWITCH) \
                   $(PROJECT_OUT)/lib/$(ARC)/opt/shared/single/libRavl$(STAMP_SINGLE_EXT) \
                   $(ABS_DESTDIR)$(libdir)/libRavl$(STAMP_SINGLE_EXT)
ifeq ($(STAMP_SINGLE),VER)
	$(SHOWIT)if [ -h $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ] || \
                    [ -f $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ] ; \
                 then \
                    $(RM) $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ; \
                 fi ; \
                 cd $(ABS_DESTDIR)$(libdir); \
                 $(LN_S) libRavl$(STAMP_SINGLE_EXT) libRavl.$(SHAREDEXT).$(PROJECT_MAJOR)
endif
ifneq ($(STAMP_SINGLE),NO)
	$(SHOWIT)if [ -h $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT) ] || \
                    [ -f $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT) ] ; \
                 then \
                    $(RM) $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT) ; \
                 fi ; \
                 cd $(ABS_DESTDIR)$(libdir); \
                 $(LN_S) libRavl$(STAMP_SINGLE_EXT) libRavl.$(SHAREDEXT)
endif
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) \
                insMustLinks recurse
	$(if $(filter 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                $(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) \
                        -f $(PROJECT_OUT)/Makefile \
                        VAR=opt SHAREDBUILD=1 LINK_PLIB=0 \
                        singlesharedSetRootStaged \
         )
#       + If we are using local (PROJECT_OUT) hard-coded paths in the built
#       binaries (i.e. --disable-fast-install is in use) we first have to
#       rebuild the libraries to reflect the installed location (i.e. $prefix,
#       $datadir, etc.).
#       + Ensure the target directory exists
#       + Rather than call the insLibs make target, we manually install the
#       library and set up the symbolic links for the less-quantified library
#       names.
#       + Install the MUSTLINK objects (the MUSTLINKs are not strictly necessary
#       for the shared library, but may be needed for old client projects that
#       have existing .def files that still include the MUSTLINKs regardless of
#       if a build is shared or not).
#       + Finally, if we are using local paths, we need to re-build the relevant
#       objects and libraries with the original path to the staging area.



installQMake:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) \
                -f @abs_builddir@/QMake/Makefile \
                STAGING=@abs_builddir@/QMake \
                STRIP_SWITCH=$(STRIP_SWITCH) \
                install

opt: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=opt NOEXEBUILD=1 \
	        $(if $(filter-out 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                     PATH_DEFINITIONS="$(INSTALLED_PATHS)" \
                 ) \
                libbuild

optbin: opt
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
	        $(if $(filter-out 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                     PATH_DEFINITIONS="$(INSTALLED_PATHS)" \
                 ) \
                fullopt

optshared: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=opt SHAREDBUILD=1 NOEXEBUILD=1 \
	        $(if $(filter-out 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                     PATH_DEFINITIONS="$(INSTALLED_PATHS)" \
                 ) \
                libbuild

optsharedobj: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=opt SHAREDBUILD=1 NOEXEBUILD=1 LINK_PLIB=0 \
	        $(if $(filter-out 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                     PATH_DEFINITIONS="$(INSTALLED_PATHS)" \
                 ) \
                libbuild

optsharedbin: optshared
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) SHAREDBUILD=1 \
	        $(if $(filter-out 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                     PATH_DEFINITIONS="$(INSTALLED_PATHS)" \
                 ) \
                fullopt

pkgconf: 
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Single \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) NOCHECKOUT=1 MAKEPKGCONFIG=1 \
                fullsrc

qmake: @NeededQMake@
#       Will equate to "LocalQMake QMake" unless we already have an installed
#       QMake when only a new copy for installation (QMake) will be needed.

QMake:
	$(MAKE) -f @abs_builddir@/QMake/Makefile \
                STAGING=@abs_builddir@/QMake
#       Stage, under @abs_builddir@/QMake, a version of QMake ready for a
#       standard install (one that will run when the makefiles are installed
#       under $(datadir)/QMake/Makefiles).

LocalQMake: 
	$(MAKE) -f @abs_builddir@/QMake/Makefile \
                prefix=@abs_builddir@ \
                STAGING=@abs_builddir@/transient/QMake
	$(MAKE) -f @abs_builddir@/QMake/Makefile \
                prefix=@abs_builddir@ \
                STAGING=@abs_builddir@/transient/QMake \
                install
#       Install a copy of QMake under the Ravl build directory in a form that
#       will run from that directory.
#       To achieve this, we have to build QMake into a staging directory and
#       then install that.


recheck: retest

retest: retestsingleoptshared 

retestgprof:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=gprof TEST_TARGET=gprof \
                retest

retestgprofshared:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=gprof SHAREDBUILD=1 TEST_TARGET=gprofshared \
                retest

retestopt:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=opt TEST_TARGET=opt \
                retest

retestoptshared:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=opt SHAREDBUILD=1 TEST_TARGET=optshared \
                retest

retestsinglegprof:
	@cd $(PROJECT_OUT)/test/gprof/single/bin; ls > ../TestExes
	cd $(PROJECT_OUT)/test/gprof/single && \
           PATH=$(PROJECT_OUT)/test/gprof/single/bin:$(PROJECT_OUT)/bin/utils/gprof/single/bin:$$PATH \
           $(PROJECT_OUT)/bin/utils/gprof/single/bin/Validate -v $(PROJECT_OUT)/test/gprof/single
	
retestsinglegprofshared:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=gprof SHAREDBUILD=1 SUMMARIES=Ravl TEST_TARGET=optshared \
                retest
	
retestsingleopt:
	@cd $(PROJECT_OUT)/test/opt/single/bin; ls > ../TestExes
	cd $(PROJECT_OUT)/test/opt/single && \
           PATH=$(PROJECT_OUT)/test/opt/single/bin:$(PROJECT_OUT)/bin/utils/opt/single/bin:$$PATH \
           $(PROJECT_OUT)/bin/utils/opt/single/bin/Validate -v $(PROJECT_OUT)/test/opt/single
	
retestsingleoptshared:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=opt SHAREDBUILD=1 SUMMARIES=Ravl TEST_TARGET=optshared \
                retest
	
#JFi:Only start of RPM process implemented. Should automate everything or drop.
rpm: qmake 
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                rpmbuild 

INSTALLED_PATHS= DEFAULT_ROOT=\\\"$(patsubst %/share,%,$(datadir))\\\" \
                 PREFIX=\\\"$(prefix)\\\" \
                 DATADIR=\\\"$(datadir)/Ravl\\\" \
                 SYSCONFDIR=\\\"$(sysconfdir)/Ravl\\\" \
                 LIBDIR=\\\"$(libdir)\\\"

SetRootInstalled:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Core/Base \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=$(VAR) NOEXEBUILD=1 \
                $(if $(SHAREDBUILD),SHAREDBUILD=$(SHAREDBUILD)) \
                $(if $(LINK_PLIB),LINK_PLIB=$(LINK_PLIB)) \
                PATH_DEFINITIONS="$(INSTALLED_PATHS)" \
                libbuild
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Contrib/Gnome \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=$(VAR) NOEXEBUILD=1 \
                $(if $(SHAREDBUILD),SHAREDBUILD=$(SHAREDBUILD)) \
                $(if $(LINK_PLIB),LINK_PLIB=$(LINK_PLIB)) \
                PATH_DEFINITIONS="$(INSTALLED_PATHS)" \
                libbuild

STAGED_PATHS= DEFAULT_ROOT=\\\"$(PROJECT_OUT)\\\" \
              PREFIX=\\\"$(PROJECT_OUT)\\\" \
              DATADIR=\\\"$(PROJECT_OUT)/share\\\" \
              SYSCONFDIR=\\\"$(PROJECT_OUT)/etc\\\" \
              LIBDIR=\\\"$(PROJECT_OUT)/lib\\\"

SetRootStaged:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Core/Base \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=$(VAR) NOEXEBUILD=1 \
                $(if $(SHAREDBUILD),SHAREDBUILD=$(SHAREDBUILD)) \
                $(if $(LINK_PLIB),LINK_PLIB=$(LINK_PLIB)) \
                PATH_DEFINITIONS="$(STAGED_PATHS)" \
                libbuild
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Contrib/Gnome \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=$(VAR) NOEXEBUILD=1 \
                $(if $(SHAREDBUILD),SHAREDBUILD=$(SHAREDBUILD)) \
                $(if $(LINK_PLIB),LINK_PLIB=$(LINK_PLIB)) \
                PATH_DEFINITIONS="$(STAGED_PATHS)" \
                libbuild

singledebug: debug
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Projects/Ravl/Makefiles/SingleLib.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=debug \
	        $(if $(filter-out 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                     PATH_DEFINITIONS="$(INSTALLED_PATHS)" \
                 ) \
                makedirs buildstatic

singledebugbin: singledebug debugbin
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Projects/Ravl/Makefiles/Recursive.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=debug SINGLELIB=1 \
	        $(if $(filter-out 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                     PATH_DEFINITIONS="$(INSTALLED_PATHS)" \
                 ) \
                programs recurse

singledebugshared: debugsharedobj
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Single \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=debug SHAREDBUILD=1 LIB_STAMP=$(STAMP_SINGLE) NOEXEBUILD=1 LINK_PLIB=0 \
	        $(if $(filter-out 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                     PATH_DEFINITIONS="$(INSTALLED_PATHS)" \
                 ) \
                libbuild

singledebugsharedbin:singledebugshared
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=debug SHAREDBUILD=1 SUMMARIES=Ravl \
	        $(if $(filter-out 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                     PATH_DEFINITIONS="$(INSTALLED_PATHS)" \
                 ) \
                exebuild

singlegprof: gprof
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Projects/Ravl/Makefiles/SingleLib.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=gprof \
                makedirs buildstatic

singlegprofbin: singlegprof gprofbin
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Projects/Ravl/Makefiles/Recursive.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=gprof SINGLELIB=1 \
                programs recurse

singlegprofshared: gprofsharedobj
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Single \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=gprof SHAREDBUILD=1 LIB_STAMP=$(STAMP_SINGLE) NOEXEBUILD=1 LINK_PLIB=0 \
                libbuild

singlegprofsharedbin: singlegprofshared
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=gprof SHAREDBUILD=1 SUMMARIES=Ravl \
                exebuild

singleopt: opt
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Projects/Ravl/Makefiles/SingleLib.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt \
	        $(if $(filter-out 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                     PATH_DEFINITIONS="$(INSTALLED_PATHS)" \
                 ) \
                makedirs buildstatic

singleoptbin: singleopt optbin
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Projects/Ravl/Makefiles/Recursive.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt SINGLELIB=1 \
	        $(if $(filter-out 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                     PATH_DEFINITIONS="$(INSTALLED_PATHS)" \
                 ) \
                programs recurse

singleoptshared: optsharedobj
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Single \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=opt SHAREDBUILD=1 LIB_STAMP=$(STAMP_SINGLE) NOEXEBUILD=1 LINK_PLIB=0 \
	        $(if $(filter-out 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                     PATH_DEFINITIONS="$(INSTALLED_PATHS)" \
                 ) \
                libbuild

singleoptsharedbin: singleoptshared
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=opt SHAREDBUILD=1 SUMMARIES=Ravl \
	        $(if $(filter-out 0 N NO No n no,$(USE_INSTALLED_PATHS)), \
                     PATH_DEFINITIONS="$(INSTALLED_PATHS)" \
                 ) \
                exebuild

singleSetRootInstalled: SetRootInstalled
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Projects/Ravl/Makefiles/SingleLib.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                makedirs buildstatic

singleSetRootStaged: SetRootStaged
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Projects/Ravl/Makefiles/SingleLib.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                makedirs buildstatic

singlesharedSetRootInstalled: SetRootInstalled
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Single \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                LIB_STAMP=$(STAMP_SINGLE) LINK_PLIB=0 NOEXEBUILD=1 \
                libbuild

singlesharedSetRootStaged: SetRootStaged
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Single \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                LIB_STAMP=$(STAMP_SINGLE) LINK_PLIB=0 NOEXEBUILD=1 \
                libbuild

test: testsingleoptshared 

testgprof:
	@$(RM) -f $(PROJECT_OUT)/test/gprof/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=gprof TEST_TARGET=gprof \
                test

testgprofshared:
	@$(RM) -f $(PROJECT_OUT)/test/gprof/shared/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=gprof SHAREDBUILD=1 TEST_TARGET=gprofshared \
                test

testopt:
	@$(RM) -f $(PROJECT_OUT)/test/opt/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=opt TEST_TARGET=opt \
                test

testoptshared:
	@$(RM) -f $(PROJECT_OUT)/test/opt/shared/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=opt SHAREDBUILD=1 TEST_TARGET=optshared \
                test

testsinglegprof:
	@$(RM) -f $(PROJECT_OUT)/test/gprof/single/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Projects/Ravl/Makefiles/Recursive.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=gprof SINGLELIB=1 \
                test recurse
	@cd $(PROJECT_OUT)/test/gprof/single/bin; ls > ../TestExes
	cd $(PROJECT_OUT)/test/gprof/single && \
           PATH=$(PROJECT_OUT)/test/gprof/single/bin:$(PROJECT_OUT)/bin/utils/gprof/single/bin:$$PATH \
           $(PROJECT_OUT)/bin/utils/gprof/single/bin/Validate -v $(PROJECT_OUT)/test/gprof/single

testsinglegprofshared:
	@$(RM) -f $(PROJECT_OUT)/test/gprof/shared/single.Ravl/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=gprof SHAREDBUILD=1 SUMMARIES=Ravl TEST_TARGET=optshared \
                test

testsingleopt:
	@$(RM) -f $(PROJECT_OUT)/test/opt/single/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Projects/Ravl/Makefiles/Recursive.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt SINGLELIB=1 \
                test recurse
	@cd $(PROJECT_OUT)/test/opt/single/bin; ls > ../TestExes
	cd $(PROJECT_OUT)/test/opt/single && \
           PATH=$(PROJECT_OUT)/test/opt/single/bin:$(PROJECT_OUT)/bin/utils/opt/single/bin:$$PATH \
           $(PROJECT_OUT)/bin/utils/opt/single/bin/Validate -v $(PROJECT_OUT)/test/opt/single
	
testsingleoptshared:
	@$(RM) -f $(PROJECT_OUT)/test/opt/shared/single.Ravl/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                VAR=opt SHAREDBUILD=1 SUMMARIES=Ravl TEST_TARGET=optshared \
                test

uninstall: uninstallQMake uninstallsingleoptshared uninstallHdrs \
           uninstallMustLinks uninstallpkgconf uninstallRavlDefs

uninstalldebuglib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=debug \
                uinsLibs recurse

uninstalldebugsharedlib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=debug SHAREDBUILD=1 \
                uinsLibs recurse

uninstallHdrs:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                uinsHdrs recurse

uninstallMustLinks:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) \
                uinsMustLinks recurse

uninstallopt: uninstalloptgeneral uninstalloptlib

uninstalloptgeneral:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt \
                uninstall recurse
#       Seperate versions of the uninstall generals exist to allow for differing
#       manifests dependant on VAR, SHAREDBUILD, etc.

uninstalloptlib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) \
                uinsLibs recurse

uninstalloptshared: uninstalloptsharedgeneral uninstalloptsharedlib

uninstalloptsharedgeneral:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt SHAREDBUILD=1 \
                uninstall recurse
#       Seperate versions of the uninstall generals exist to allow for differing
#       manifests dependant on VAR, SHAREDBUILD, etc.

uninstalloptsharedlib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt SHAREDBUILD=1 STRIP_SWITCH=$(STRIP_SWITCH) \
                uinsLibs recurse

uninstallpkgconf: 
	@if [ -f $(ABS_DESTDIR)$(libdir)/pkgconfig/Ravl.pc ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/pkgconfig/Ravl.pc ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/pkgconfig/Ravl.pc ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi

uninstallQMake:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) \
                -f @abs_builddir@/QMake/Makefile \
                uninstall

uninstallRavlDefs: uninstallRavlMultiDefs uninstallRavl.def

uninstallRavlMultiDefs:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=debug SHAREDBUILD=1 STRIP_SWITCH=$(STRIP_SWITCH) PROJECT_DIR=Ravl \
                uinsDefs recurse

uninstallRavl.def:
	@if [ -f $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/Ravl.def ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/Ravl.def ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/Ravl.def ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi

uninstallsingledebuglib:
	@if [ -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.a ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.a ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.a ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi

uninstallsingledebugsharedlib:
	@if [ -h $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl$(STAMP_SINGLE_EXT) ] || \
            [ -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl$(STAMP_SINGLE_EXT) ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl$(STAMP_SINGLE_EXT) ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl$(STAMP_SINGLE_EXT) ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi
ifeq ($(STAMP_SINGLE),VER)
	@if [ -h $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ] || \
            [ -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi
endif
ifneq ($(STAMP_SINGLE),NO)
	@if [ -h $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT) ] || \
            [ -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT) ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT) ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT) ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi
endif
#        Removal of libRavl$(STAMP_SINGLE_EXT) will alway remove the actual
#        library file. If we are version stamping the single library, we will
#        then need to remove the symbolic links from the lesser qualified names

uninstallsingleopt:uninstallsingleoptgeneral uninstallsingleoptlib

uninstallsingleoptgeneral: 
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt \
                uninstall recurse
#       Seperate versions of the uninstall generals exist to allow for differing
#       manifests dependant on VAR, SHAREDBUILD, etc.

uninstallsingleoptlib:
	@if [ -f $(ABS_DESTDIR)$(libdir)/libRavl.a ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl.a ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl.a ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi

uninstallsingleoptshared: uninstallsingleoptsharedgeneral  uninstallsingleoptsharedlib

uninstallsingleoptsharedgeneral:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) \
                -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk \
                CONFIGFILE=$(PROJECT_OUT)/Config.Project \
                VAR=opt SHARED_LIB_POSTFIX=/shared/single SHAREDBUILD=1 \
                uninstall recurse
#       Seperate versions of the uninstall generals exist to allow for differing
#       manifests dependant on VAR, SHAREDBUILD, etc.

uninstallsingleoptsharedlib:
	@if [ -h $(ABS_DESTDIR)$(libdir)/libRavl$(STAMP_SINGLE_EXT) ] || \
            [ -f $(ABS_DESTDIR)$(libdir)/libRavl$(STAMP_SINGLE_EXT) ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl$(STAMP_SINGLE_EXT) ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl$(STAMP_SINGLE_EXT) ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi
ifeq ($(STAMP_SINGLE),VER)
	@if [ -h $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ] || \
            [ -f $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi
endif
ifneq ($(STAMP_SINGLE),NO)
	@if [ -h $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT) ] || \
            [ -f $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT) ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT) ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT) ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi
endif
#        Removal of libRavl$(STAMP_SINGLE_EXT) will alway remove the actual
#        library file. If we are version stamping the single library, we will
#        then need to remove the symbolic links from the lesser qualified names



.DEFAULT: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                $@

#JFi:ToDo Targets for clean ctags distclean distcheck html install-check
#                     install-html install-pdf installdirs mostlyclean
#                     maintainter-clean pdf tags


.PHONY: check debug debugshared debugsharedobj default dist doc fullsrc \
 gprof gprofbin gprofshared gprofsharedobj gprofsharedbin install \
 install-strip install-stripProject installdebuglib installdebugsharedlib \
 installHdrs installopt installoptlib installoptshared installoptsharedgeneral \
 installoptsharedlib installProject installpkgconf installQMake \
 installRavlDefs installRavlMultiDefs installsingledebuglib \
 installsingledebugsharedlib installsingleopt installsingleoptlib \
 installsingleoptshared installsingleoptsharedgeneral \
 installsingleoptsharedlib LocalQMake opt optbin optshared optsharedobj \
 optsharedbin pkgconf qmake QMake recheck retest retestgprof retestgprofshared \
 retestopt retestoptshared retestsinglegprof retestsinglegprofshared \
 retestsingleopt retestsingleoptshared rpm SetRootInstalled SetRootStaged \
 singledebug singledebugbin singledebugshared singledebugsharedbin singlegprof \
 singlegprofbin singlegprofshared singlegprofsharedbin singleopt singleoptbin \
 singleoptshared singleoptsharedbin singleSetRootInstalled singleSetRootStaged \
 singlesharedSetRootInstalled singlesharedSetRootStaged test testgprof \
 testgprofshared testopt testoptshared testsinglegprof testsinglegprofshared \
 testsingleopt testsingleoptshared uninstall uninstalldebuglib \
 uninstalldebugsharedlib uninstallHdrs uninstallMustLinks uninstallopt \
 uninstalloptgeneral uninstalloptlib uninstalloptshared \
 uninstalloptsharedgeneral uninstalloptsharedlib uninstallpkgconf \
 uninstallQMake uninstallRavl.def uninstallRavlDefs uninstallRavlMultiDefs \
 uninstallsingledebuglib uninstallsingledebugsharedlib uninstallsingleopt \
 uninstallsingleoptgeneral uninstallsingleoptlib uninstallsingleoptshared \
 uninstallsingleoptsharedgeneral uninstallsingleoptsharedlib .DEFAULT

