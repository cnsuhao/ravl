# @configure_input@
# This file is part of RAVL, Recognition And Vision Library
# Copyright (C) 2011-13, University of Surrey
# This code may be redistributed under the terms of the GNU General
# Public License (GPL). See the gpl.licence file for details or
# see http://www.gnu.org/copyleft/gpl.html

SOURCEHOME=@abs_srcdir@/src

PROJECT_OUT=@abs_builddir@

WORKING_QMAKE=@WORKING_QMAKE@

# Ensure any DESTDIR is an absolute path
ifdef DESTDIR
  ABS_DESTDIR=$(abspath $(DESTDIR))

  # Propogate absolute path going forward
  SET_DESTDIR=DESTDIR=$(ABS_DESTDIR)
endif

# Include QMake global definitions
include @QMAKE_CONFIGFILES@/Config.QMake

# Include project specific definitions
include $(PROJECT_OUT)/Config.Project

# Include project specific installation targets
include $(PROJECT_OUT)/Targets.Project

# RAVL Makefile and default flags for QMake and RAVL itself

RAVL_MAKEFILE=$(WORKING_QMAKE)/Makefiles/QMake.mk

RAVL_FLAGS=BASEINSTALL=1 FULLBUILDSRC='BASE_VAR=none' CONFIGFILE=$(PROJECT_OUT)/Config.Project INCLUDEDIR=$(PROJECT_OUT)/include 

# Trace commands if QMAKE_INFO is in use
ifndef QMAKE_INFO
SHOWIT=@
else
SHOWIT=
endif

# Control version stamping of single-shared library
ifndef STAMP_SINGLE
 ifdef LIB_STAMP
  STAMP_SINGLE=$(LIB_STAMP)
 else
  STAMP_SINGLE=VER
  # Default to full version stamping
 endif
endif

ifeq ($(STAMP_SINGLE),VER)
 STAMP_SINGLE_EXT=.so.$(PROJECT_VERSION)
else
 ifeq ($(STAMP_SINGLE),NO)
  # Version stamping switched off
  STAMP_SINGLE_EXT=.so
 else
  STAMP_SINGLE_EXT=.so.$(PROJECT_MAJOR)
 endif
endif

# Builds

default: qmake fullsrc singleoptshared optsharedbin singleoptsharedbin pkgconf Ravl.def

check: testsingleoptshared 

debug: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=debug NOEXEBUILD=1 libbuild

debugshared: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=debug SHAREDBUILD=1 NOEXEBUILD=1 libbuild

dist:
	$(MAKE) -C @abs_srcdir@ -f $(WORKING_QMAKE)/Makefiles/Dist.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project dist

doc: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/.. -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) PROJECT_NAME=Ravl PROJECT_DESC="RAVL, Recognition And Vision Library" fulldoc
	cp $(PROJECT_OUT)/share/QMake/Support/Help.txt $(PROJECT_OUT)/share/doc/Ravl/html/Help.txt
#       We currently start from above the src directory ($SOURCEHOME)/..) in
#       order to pick up the documentation from QMake. This is because there is
#       currently no framework to link to documentation from another project.
#       This means we cannot produce the QMake documentation from within that
#       seperate project and link to that from the Ravl documentation. We
#       therefore have to treat the QMake documentation as if it was part Ravl,
#       hence the start point.
#
#       PROJECT_NAME setting is to force the examples and other html files into
#       the correct directory. This is required because Ravl currently does not
#       use PACKAGE and PROJECT_NAME in the designed way for QMake. Ravl will
#       currently use a PACKAGE setting of Ravl/pkg rather than setting
#       PROJECT_NAME to Ravl and setting PACKAGE to pkg. This cannot currently
#       be changed until ccmath is moved out of the Ravl source tree and used as
#       a seperate external library.
#
#       Final step copies across the QMake help file; this is again due to there
#       being no existing mechanism to link to documentation in an external
#       project.

fullsrc: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) NOCHECKOUT=1 fullsrc

gprof: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=gprof NOEXEBUILD=1 libbuild

gprofbin: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) fullgprof

gprofshared: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=gprof SHAREDBUILD=1 NOEXEBUILD=1 libbuild

gprofsharedbin: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) SHAREDBUILD=1 fullgprof

install: installQMake installProject

installProject: installsingleoptshared installHdrs installpkgconf installRavl.def installDummyDefs

install-strip:
	$(MAKE) STRIP_SWITCH="-s" install

install-stripProject:
	$(MAKE) STRIP_SWITCH="-s" installProject

BUILT_DOT_DEFS=$(filter-out Ravl.def, $(patsubst $(PROJECT_OUT)/lib/libdep/%,%,$(wildcard $(PROJECT_OUT)/lib/libdep/*)))
# List of .def files created by build process (minus the single library's
# Ravl.def). Listed as simple filename-only form.

DUMMY_DOT_DEFS=$(patsubst %,$(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/%, $(BUILT_DOT_DEFS))
# List of dummy .def files we should install (listed with installation target
# path).

define installddd
  $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/$1: $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep
	@echo \# Dummy Dot Def file >  $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/$1
endef

$(foreach dotdef,$(BUILT_DOT_DEFS),$(eval $(call installddd,$(dotdef))))
 
installDummyDefs: $(DUMMY_DOT_DEFS)

               


# All the install targets recurse down the source directories using the defs.mk
# files to determine what needs installing. The relevant files are then
# installed from their built location in the build tree.

installHdrs:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project insHdrs recurse

installopt:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt SetRootInstalled
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile optbin
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project AUXHOME=Ravl VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) install recurse
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) insLibs recurse
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt SetRootStaged
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile optbin
#       First re-link those modules that need to be built with the location of
#       the library reflected in the code. 
#       Re-make the binaries to pick up the path changes
#       Use the 'install' function of QMake to install the Ravl utility
#       binaries; config files; data files and scripts. 
#       Restore the embedded paths to point to the staged location of Ravl
#       Rebuild the binaries to pick up the path resotoration
#       N.B. This recepie includes a duplication of parts of the installoptlib
#       recepie (we can not use the XXXgeneral XXXlib form used by the shared
#       recepies because of the need to rebuild the binaries to pick up the
#       change in resource-root). Please remember to apply any changes to the
#       other copy of the code as appropriate.

installoptlib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt SetRootInstalled
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) insLibs recurse
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt SetRootStaged
#       First re-link those modules that need to be built with the location of
#       the library reflected in the code. Install the libraries via QMake and
#       re-build the relevant objects/libraries with the original path to the
#       staging area.
#       N.B. Parts of this recepie are duplicated in the installopt recepie (we
#       can not use the XXXgeneral XXXlib form used by the shared recepies
#       because of the need to rebuild the binaries to pick up the change in
#       resource-root). Please remember to apply any changes to the other copy
#       of the code as appropriate.

installoptshared: installoptsharedgeneral installoptsharedlib

installoptsharedgeneral:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project AUXHOME=Ravl VAR=opt SHAREDBUILD=1 STRIP_SWITCH=$(STRIP_SWITCH) install recurse
#       Use the 'install' function of QMake to install the Ravl utility
#       binaries; config files; data files and scripts. 

installoptsharedlib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt SHAREDBUILD=1 SetRootInstalled
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SHAREDBUILD=1 STRIP_SWITCH=$(STRIP_SWITCH) insLibs recurse
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt SHAREDBUILD=1 SetRootStaged
#       First re-link those modules that need to be built with the location of
#       the library reflected in the code. Install the libraries via QMake and
#       re-build the relevant objects/libraries with the original path to the
#       staging area.

installpkgconf: $(ABS_DESTDIR)$(libdir)/pkgconfig $(ABS_DESTDIR)$(libdir)/pkgconfig/Ravl.pc

$(ABS_DESTDIR)$(libdir)/pkgconfig:
	$(SHOWIT)$(MKDIR_P) $(ABS_DESTDIR)$(libdir)/pkgconfig

$(ABS_DESTDIR)$(libdir)/pkgconfig/Ravl.pc:
	$(INSTALL_DATA) $(PROJECT_OUT)/lib/pkgconfig/Ravl.pc $(ABS_DESTDIR)$(libdir)/pkgconfig/Ravl.pc

installRavl.def:  $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep
	$(INSTALL) $(PROJECT_OUT)/lib/libdep/4install/Ravl.def $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/Ravl.def

$(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep:
	$(SHOWIT)$(MKDIR_P) $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep

installsingleopt:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt singleSetRootInstalled
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile singleoptbin
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project AUXHOME=Ravl VAR=opt SHARED_LIB_POSTFIX=/single STRIP_SWITCH=$(STRIP_SWITCH) install recurse
	$(SHOWIT)if [ ! -d $(ABS_DESTDIR)$(libdir) ] ; then $(MKDIR_P) $(ABS_DESTDIR)$(libdir) ; fi
	$(INSTALL) $(STRIP_SWITCH) $(PROJECT_OUT)/lib/$(ARC)/opt/single/libRavl.a $(ABS_DESTDIR)$(libdir)/libRavl.a
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt singleSetRootStaged
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile singleoptbin
#       First rebuild those modules that rely on the installation path and
#       relink their libraries. 
#       When this is complete, the binaries are rebuilt to pick up the path
#       changes.
#       We can then use the 'install' function of QMake to install these
#       binaries along with the Ravl config files; data files and scripts. We
#       must set SHARED_LIB_POSTFIX (to /single) in order to force QMake to use
#       the version of the binaries compiled against the single shared Ravl
#       library rather than the more usual (for QMake) individual shared
#       libraries. 
#       Rather than call the insLibs make target, we manually copy across the
#       single library having first ensured the target directory exists.
#       Finally, we restore the local path into the object and library files
#       and then remake the binaries to pick up the restore.
#       N.B. This recepie includes a duplication of parts of the recepie for
#       installsingleoptlib (we can not use the XXXgeneral XXXlib form used by
#       the shared recepies because of the need to rebuild the binaries to pick
#       up the change in resource-root). Please remember to apply any changes
#       to the other copy of the code as appropriate.

installsingleoptlib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt singleSetRootInstalled
	$(SHOWIT)if [ ! -d $(ABS_DESTDIR)$(libdir) ] ; then $(MKDIR_P) $(ABS_DESTDIR)$(libdir) ; fi
	$(INSTALL) $(STRIP_SWITCH) $(PROJECT_OUT)/lib/$(ARC)/opt/single/libRavl.a $(ABS_DESTDIR)$(libdir)/libRavl.a
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt singleSetRootStaged
#       First rebuild those modules that rely on the installation path and
#       relink their libraries. 
#       Ensure the target dir exists and manually copy across the library.
#       Finally, we restore the local path into the object and library files.
#       N.B. Parts of this recepie are duplicated in the installsingleopt
#       recepie (we can not use the XXXgeneral XXXlib form used by the shared
#       recepies because of the need to rebuild the binaries to pick up the
#       change in resource-root). Please remember to apply any changes to the
#       other copy of the code as appropriate.

installsingleoptshared:installsingleoptsharedgeneral installsingleoptsharedlib

installsingleoptsharedgeneral:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project AUXHOME=Ravl VAR=opt SHARED_LIB_POSTFIX=/shared/single SHAREDBUILD=1 STRIP_SWITCH=$(STRIP_SWITCH) install recurse
#       Use the 'install' function of QMake to install the Ravl utility
#       binaries; config files; data files and scripts. We must set
#       SHARED_LIB_POSTFIX (to /shared/single) in order to force QMake to use
#       the version of the binaries compiled against the single shared Ravl
#       library rather than the more usual (for QMake) individual shared
#       libraries. 

installsingleoptsharedlib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt SHAREDBUILD=1 singlesharedSetRootInstalled
	$(SHOWIT)if [ ! -d $(ABS_DESTDIR)$(libdir) ] ; then $(MKDIR_P) $(ABS_DESTDIR)$(libdir) ; fi
	$(INSTALL) $(STRIP_SWITCH) $(PROJECT_OUT)/lib/$(ARC)/opt/shared/single/libRavl$(STAMP_SINGLE_EXT) $(ABS_DESTDIR)$(libdir)/libRavl$(STAMP_SINGLE_EXT)
ifeq ($(STAMP_SINGLE),VER)
	$(SHOWIT)if [ -h $(ABS_DESTDIR)$(libdir)/libRavl.so.$(PROJECT_MAJOR) ] || [ -f $(ABS_DESTDIR)$(libdir)/libRavl.so.$(PROJECT_MAJOR) ] ; \
                 then \
                    $(RM) $(ABS_DESTDIR)$(libdir)/libRavl.so.$(PROJECT_MAJOR) ; \
                 fi ; \
                 cd $(ABS_DESTDIR)$(libdir); $(LN_S) libRavl$(STAMP_SINGLE_EXT) libRavl.so.$(PROJECT_MAJOR) ; \
                 fi
endif
ifneq ($(STAMP_SINGLE),NO)
	$(SHOWIT)if [ -h $(ABS_DESTDIR)$(libdir)/libRavl.so ] || [ -f $(ABS_DESTDIR)$(libdir)/libRavl.so ] ; \
                 then \
                    $(RM) $(ABS_DESTDIR)$(libdir)/libRavl.so ; \
                 fi ; \
                 cd $(ABS_DESTDIR)$(libdir); $(LN_S) libRavl$(STAMP_SINGLE_EXT) libRavl.so ; \
                 fi
endif
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt SHAREDBUILD=1 singlesharedSetRootStaged
#       First rebuild those modules that rely on the installation path and
#       relink their libraries and the single library itself. 
#       Then ensure the target directory exists and manually copy across the
#       single shared library.
#       If required, we set up the symbolic links for the less-quantified
#       library names.
#       Finally, we restore the local path into the object/library files.


installQMake:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -f @abs_builddir@/QMake/Makefile STAGING=@abs_builddir@/QMake STRIP_SWITCH=$(STRIP_SWITCH) install

opt: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt NOEXEBUILD=1 libbuild

optbin: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) fullopt

optshared: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt SHAREDBUILD=1 NOEXEBUILD=1 libbuild

optsharedbin: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) SHAREDBUILD=1 fullopt

pkgconf: $(PROJECT_OUT)/lib/pkgconfig $(PROJECT_OUT)/lib/pkgconfig/Ravl.pc

$(PROJECT_OUT)/lib/pkgconfig:
	$(SHOWIT) $(MKDIR_P) $@

$(PROJECT_OUT)/lib/pkgconfig/Ravl.pc:
	$(SHOWIT)echo prefix=$(prefix) > $@
	$(SHOWIT)echo datarootdir=$(datarootdir) >> $@
	$(SHOWIT)echo datadir=$(datadir) >> $@
	$(SHOWIT)echo sysconfdir=$(sysconfdir) >> $@
	$(SHOWIT)echo libdir=$(libdir) >> $@
	$(SHOWIT)echo >> $@
	$(SHOWIT)echo Name: Ravl >> $@
	$(SHOWIT)echo Version: @PACKAGE_VERSION@ >> $@
	$(SHOWIT)echo Description: Recognition And Vision Library with modules for Computer Vision, Pattern Recognition and much more >> $@
	$(SHOWIT)echo URL: @PACKAGE_URL@ >> $@
	$(SHOWIT)echo >> $@
	$(SHOWIT)echo Libs:-L\${libdir} -lRavl >> $@
	$(SHOWIT)echo Libs.private:$(ALL_EXTERNAL_LIBS)>> $@
	$(SHOWIT)echo Cflags:-I\${includedir}>> $@
	$(SHOWIT)echo >> $@

qmake: @NeededQMake@
#       Will equate to "LocalQMake QMake" unless we already have an installed
#       QMake when only a new copy for installation (QMake) will be needed.

QMake:
	$(MAKE) -f @abs_builddir@/QMake/Makefile STAGING=@abs_builddir@/QMake
#       Stage, under @abs_builddir@/QMake, a version of QMake ready for a
#       standard install (one that will run when the makefiles are installed
#       under $(datadir)/QMake/Makefiles).

LocalQMake: 
	$(MAKE) -f @abs_builddir@/QMake/Makefile DESTDIR=staged bindir=@abs_builddir@/share/QMake/bin \
                         datadir=@abs_builddir@/share sysconfdir=@abs_builddir@ STAGING=@abs_builddir@/share/QMake
	$(SHOWIT)if [ ! -f @abs_builddir@/share/QMake/bin/Validate ]; \
                 then \
                   if [ ! -h @abs_builddir@/share/QMake/bin/Validate ]; \
                   then \
                     cd @abs_builddir@/share/QMake/bin; \
                     $(LN_S) @abs_builddir@/bin/Validate Validate; \
                   fi \
                 fi
#       Stage QMake under the Ravl build directory in a form that will run from
#       that directory.
#       To achieve this, we have to set the destination for both the staging and
#       install targets to be the same for the makefiles. The install target for
#       the makefiles uses $(datadir)/QMake/Makefiles as its destination, while
#       the staging target uses $(STAGING)/Makefiles; hence the slightly
#       different values for those two variables. DESTDIR=staged prevents make
#       complaining about using identical destinations for both the staged and
#       install targets. As we are only staging and not performing an install,
#       DESTDIR will have no other effect and gives us the functionality we are
#       looking for. As well as $(datadir), $(sysconfdir) automatically has
#       /QMake suffixed to it for the install process, hence the value of
#       $(sysconfdir) that is used here.
#       The final symbolic link allows the local QMake to find Validate that,
#       while it should be part of QMake, is currently part of RAVL. This last
#       stage is a bit of a bodge as it won't work on platforms that do not
#       support symbolic links (as the target doesn't actually exist at this
#       point). The proper solution is to uncouple Validate from RAVL (re-write
#       it) and move it into QMake.


Ravl.def: $(PROJECT_OUT)/lib/libdep $(PROJECT_OUT)/lib/libdep/Ravl.def $(PROJECT_OUT)/lib/libdep/4install $(PROJECT_OUT)/lib/libdep/4install/Ravl.def

$(PROJECT_OUT)/lib/libdep:
	$(SHOWIT) $(MKDIR_P) $@

$(PROJECT_OUT)/lib/libdep/Ravl.def:
	$(SHOWIT)echo \# Dummy dot def > $@
	$(SHOWIT)echo \# >> $@
	$(SHOWIT)echo \# Dummy file to prevent single Ravl library being used by a qm in the Ravl source dirs >> $@
	$(SHOWIT)echo \# >> $@
	$(SHOWIT)echo \# Real Ravl.def file can be found in the 4install sub-directory>> $@
	$(SHOWIT)echo \# >> $@

$(PROJECT_OUT)/lib/libdep/4install:
	$(SHOWIT) $(MKDIR_P) $@

$(PROJECT_OUT)/lib/libdep/4install/Ravl.def: $(PROJECT_OUT)/Makefile  $(PROJECT_OUT)/Config.Project @QMAKE_CONFIGFILES@/Config.QMake
	$(SHOWIT)echo \# This file is part of RAVL, Recognition And Vision Library > $@
	$(SHOWIT)echo \# Copyright \(C\) 2001-13,  University of Surrey. >> $@
	$(SHOWIT)echo \# This code may be redistributed under the terms of the GNU Lesser >> $@
	$(SHOWIT)echo \# General Public License \(LGPL\). See the lgpl.licence file for details or >> $@
	$(SHOWIT)echo \# see http://www.gnu.org/copyleft/lesser.html >> $@
	$(SHOWIT)echo \# file-header-ends-here >> $@
	$(SHOWIT)echo >> $@
	$(SHOWIT)echo ifndef RAVL_DEF >> $@
	$(SHOWIT)echo >> $@
	$(SHOWIT)echo "  RAVL_DEF=1" >> $@
	$(SHOWIT)echo >> $@
	$(SHOWIT)echo "  ifndef RAVL_LIBS" >> $@
	$(SHOWIT)echo "    RAVL_LIBS=-L$(libdir) -lRavl $(ALL_EXTERNAL_LIBS)" >> $@
	$(SHOWIT)echo "  endif" >> $@
	$(SHOWIT)echo >> $@
	$(SHOWIT)echo "  EXELIB := \$$(RAVL_LIBS) \$$(EXELIB)" >> $@
	$(SHOWIT)echo >> $@
	$(SHOWIT)echo "  ifndef RAVL_CFLAGS" >> $@
	$(SHOWIT)echo "    RAVL_CFLAGS=-I$(includedir) $(ALL_EXTERNAL_CFLAGS)" >> $@
	$(SHOWIT)echo "  endif" >> $@
	$(SHOWIT)echo >> $@
	$(SHOWIT)echo "  INCLUDES += \$$(RAVL_CFLAGS)" >> $@
	$(SHOWIT)echo >> $@
	$(SHOWIT)echo endif >> $@
	$(SHOWIT)echo >> $@


recheck: retest

retest: retestsingleoptshared 

retestgprof:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=gprof TEST_TARGET=gprof retest

retestgprofshared:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=gprof SHAREDBUILD=1 TEST_TARGET=gprofshared retest

retestopt:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt TEST_TARGET=opt retest

retestoptshared:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt SHAREDBUILD=1 TEST_TARGET=optshared retest

retestsinglegprof:
	@cd $(PROJECT_OUT)/test/gprof/single/bin; ls > ../TestExes
	cd $(PROJECT_OUT)/test/gprof/single && \
           PATH=$(PROJECT_OUT)/test/gprof/single/bin:$(PROJECT_OUT)/bin/utils/gprof/single/bin:$$PATH \
           $(PROJECT_OUT)/bin/utils/gprof/single/bin/Validate -v $(PROJECT_OUT)/test/gprof/single
	
retestsinglegprofshared:
	@cd $(PROJECT_OUT)/test/gprof/shared/single/bin; ls > ../TestExes
	cd $(PROJECT_OUT)/test/gprof/shared/single && \
           PATH=$(PROJECT_OUT)/test/gprof/shared/single/bin:$(PROJECT_OUT)/bin/utils/gprof/shared/single/bin:$$PATH \
           LD_LIBRARY_PATH=$(PROJECT_OUT)/lib/$(ARC)/gprof/shared/single:$$LD_LIBRARY_PATH \
           $(PROJECT_OUT)/bin/utils/gprof/shared/single/bin/Validate -v $(PROJECT_OUT)/test/gprof/shared/single
	
retestsingleopt:
	@cd $(PROJECT_OUT)/test/opt/single/bin; ls > ../TestExes
	cd $(PROJECT_OUT)/test/opt/single && \
           PATH=$(PROJECT_OUT)/test/opt/single/bin:$(PROJECT_OUT)/bin/utils/opt/single/bin:$$PATH \
           $(PROJECT_OUT)/bin/utils/opt/single/bin/Validate -v $(PROJECT_OUT)/test/opt/single
	
retestsingleoptshared:
	@cd $(PROJECT_OUT)/test/opt/shared/single/bin; ls > ../TestExes
	cd $(PROJECT_OUT)/test/opt/shared/single && \
           PATH=$(PROJECT_OUT)/test/opt/shared/single/bin:$(PROJECT_OUT)/bin/utils/opt/shared/single/bin:$$PATH \
           LD_LIBRARY_PATH=$(PROJECT_OUT)/lib/$(ARC)/opt/shared/single:$$LD_LIBRARY_PATH \
           $(PROJECT_OUT)/bin/utils/opt/shared/single/bin/Validate -v $(PROJECT_OUT)/test/opt/shared/single
	
#JFi:Only start of RPM process implemented. Should automate everything or drop.
rpm: qmake 
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) rpmbuild 

SetRootInstalled:
	$(SHOWIT)touch $(SOURCEHOME)/Core/Base/Resource.cc
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Core/Base -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                CCFLAGS="$(CCFLAGS) -DDEFAULT_ROOT=\\\"$(datadir)/Ravl\\\"" NOEXEBUILD=1 libbuild
	$(SHOWIT)touch $(SOURCEHOME)/Contrib/Gnome/Gnome.cc
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Contrib/Gnome -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) \
                CCFLAGS="$(CCFLAGS) -DPREFIX=\\\"$(prefix)\\\" -DDATADIR=\\\"$(datadir)/Ravl\\\" -DSYSCONFDIR=\\\"$(sysconfdir)/Ravl\\\" -DLIBDIR=\\\"$(libdir)\\\"" \
                NOEXEBUILD=1 libbuild

SetRootStaged:
	$(SHOWIT)touch $(SOURCEHOME)/Core/Base/Resource.cc
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Core/Base -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) NOEXEBUILD=1 libbuild
	$(SHOWIT)touch $(SOURCEHOME)/Contrib/Gnome/Gnome.cc
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Contrib/Gnome -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) NOEXEBUILD=1 libbuild

singledebug:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/SingleLib.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=debug makedirs buildstatic

singledebugbin:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/Recursive.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=debug SINGLELIB=1 programs recurse

singledebugshared: debugshared
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Single -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=debug SHAREDBUILD=1 LIB_STAMP=$(STAMP_SINGLE) NOEXEBUILD=1 libbuild

singledebugsharedbin:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/Recursive.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=debug SINGLELIB=1 SHAREDBUILD=1 programs recurse

singlegprof:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/SingleLib.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=gprof makedirs buildstatic

singlegprofbin:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/Recursive.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=gprof SINGLELIB=1 programs recurse

singlegprofshared: gprofshared
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Single -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=gprof SHAREDBUILD=1 LIB_STAMP=$(STAMP_SINGLE) NOEXEBUILD=1 libbuild

singlegprofsharedbin:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/Recursive.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=gprof SINGLELIB=1 SHAREDBUILD=1 programs recurse

singleopt:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/SingleLib.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt makedirs buildstatic

singleoptbin:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/Recursive.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SINGLELIB=1 programs recurse

singleoptshared: optshared
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Single -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt SHAREDBUILD=1 LIB_STAMP=$(STAMP_SINGLE) NOEXEBUILD=1 libbuild

singleoptsharedbin:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/Recursive.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SINGLELIB=1 SHAREDBUILD=1 programs recurse

singleSetRootInstalled: SetRootInstalled
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/SingleLib.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project makedirs buildstatic

singleSetRootStaged: SetRootStaged
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/SingleLib.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project makedirs buildstatic

singlesharedSetRootInstalled: SetRootInstalled
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Single -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) LIB_STAMP=$(STAMP_SINGLE) NOEXEBUILD=1 libbuild

singlesharedSetRootStaged: SetRootStaged
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Single -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) LIB_STAMP=$(STAMP_SINGLE) NOEXEBUILD=1 libbuild

test: testsingleoptshared 

testgprof:
	@$(RM) -f $(PROJECT_OUT)/test/gprof/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=gprof TEST_TARGET=gprof test

testgprofshared:
	@$(RM) -f $(PROJECT_OUT)/test/gprof/shared/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=gprof SHAREDBUILD=1 TEST_TARGET=gprofshared test

testopt:
	@$(RM) -f $(PROJECT_OUT)/test/opt/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt TEST_TARGET=opt test

testoptshared:
	@$(RM) -f $(PROJECT_OUT)/test/opt/shared/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt SHAREDBUILD=1 TEST_TARGET=optshared test

testsinglegprof:
	@$(RM) -f $(PROJECT_OUT)/test/gprof/single/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/Recursive.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=gprof SINGLELIB=1 test recurse
	@cd $(PROJECT_OUT)/test/gprof/single/bin; ls > ../TestExes
	cd $(PROJECT_OUT)/test/gprof/single && \
           PATH=$(PROJECT_OUT)/test/gprof/single/bin:$(PROJECT_OUT)/bin/utils/gprof/single/bin:$$PATH \
           $(PROJECT_OUT)/bin/utils/gprof/single/bin/Validate -v $(PROJECT_OUT)/test/gprof/single

testsinglegprofshared:
	@$(RM) -f $(PROJECT_OUT)/test/gprof/shared/single/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/Recursive.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=gprof SINGLELIB=1 SHAREDBUILD=1 test recurse
	@cd $(PROJECT_OUT)/test/gprof/shared/single/bin; ls > ../TestExes
	cd $(PROJECT_OUT)/test/gprof/shared/single && \
           PATH=$(PROJECT_OUT)/test/gprof/shared/single/bin:$(PROJECT_OUT)/bin/utils/gprof/shared/single/bin:$$PATH \
           LD_LIBRARY_PATH=$(PROJECT_OUT)/lib/$(ARC)/gprof/shared/single:$$LD_LIBRARY_PATH \
           $(PROJECT_OUT)/bin/utils/gprof/shared/single/bin/Validate -v $(PROJECT_OUT)/test/gprof/shared/single

testsingleopt:
	@$(RM) -f $(PROJECT_OUT)/test/opt/single/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/Recursive.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SINGLELIB=1 test recurse
	@cd $(PROJECT_OUT)/test/opt/single/bin; ls > ../TestExes
	cd $(PROJECT_OUT)/test/opt/single && \
           PATH=$(PROJECT_OUT)/test/opt/single/bin:$(PROJECT_OUT)/bin/utils/opt/single/bin:$$PATH \
           $(PROJECT_OUT)/bin/utils/opt/single/bin/Validate -v $(PROJECT_OUT)/test/opt/single
	
testsingleoptshared:
	@$(RM) -f $(PROJECT_OUT)/test/opt/shared/single/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/Recursive.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SINGLELIB=1 SHAREDBUILD=1 test recurse
	@cd $(PROJECT_OUT)/test/opt/shared/single/bin; ls > ../TestExes
	cd $(PROJECT_OUT)/test/opt/shared/single && \
           PATH=$(PROJECT_OUT)/test/opt/shared/single/bin:$(PROJECT_OUT)/bin/utils/opt/shared/single/bin:$$PATH \
           LD_LIBRARY_PATH=$(PROJECT_OUT)/lib/$(ARC)/opt/shared/single:$$LD_LIBRARY_PATH \
           $(PROJECT_OUT)/bin/utils/opt/shared/single/bin/Validate -v $(PROJECT_OUT)/test/opt/shared/single

uninstall: uninstallQMake uninstallsingleoptshared uninstallHdrs uninstallpkgconf uninstallRavl.def uninstallDummyDefs

uninstallDummyDefs:
	@for f in $(BUILT_DOT_DEFS) ; \
         do \
            if [ -f $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/$$f ] ; \
            then \
               if [ X$(QMAKE_INFO) != X ] ;\
               then \
                  echo $(RM) -f $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/$$f ; \
               fi ;\
               $(RM) -f $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/$$f ; \
               RET=$$? ; \
               if [ $$RET -ne 0 ] ; \
               then \
                  exit $$RET ;\
               fi ;\
            fi ;\
         done

uninstallHdrs:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project uinsHdrs recurse

uninstallopt: uninstalloptgeneral uninstalloptlib

uninstalloptgeneral:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project AUXHOME=Ravl VAR=opt uninstall recurse
#       Seperate versions of the uninstall generals exist to allow for differing
#       manifests dependant on VAR, SHAREDBUILD, etc.

uninstalloptlib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) uinsLibs recurse

uninstalloptshared: uninstalloptsharedgeneral uninstalloptsharedlib

uninstalloptsharedgeneral:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project AUXHOME=Ravl VAR=opt SHAREDBUILD=1 uninstall recurse
#       Seperate versions of the uninstall generals exist to allow for differing
#       manifests dependant on VAR, SHAREDBUILD, etc.

uninstalloptsharedlib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SHAREDBUILD=1 STRIP_SWITCH=$(STRIP_SWITCH) uinsLibs recurse

uninstallpkgconf: 
	@if [ -f $(ABS_DESTDIR)$(libdir)/pkgconfig/Ravl.pc ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/pkgconfig/Ravl.pc ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/pkgconfig/Ravl.pc ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi

uninstallQMake:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -f @abs_builddir@/QMake/Makefile uninstall

uninstallRavl.def:
	@if [ -f $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/Ravl.def ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/Ravl.def ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/Ravl.def ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi

uninstallsingleopt:uninstallsingleoptgeneral uninstallsingleoptlib

uninstallsingleoptgeneral: 
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project AUXHOME=Ravl VAR=opt uninstall recurse
#       Seperate versions of the uninstall generals exist to allow for differing
#       manifests dependant on VAR, SHAREDBUILD, etc.

uninstallsingleoptlib:
	@if [ -f $(ABS_DESTDIR)$(libdir)/libRavl.a ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl.a ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl.a ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi

uninstallsingleoptshared: uninstallsingleoptsharedgeneral  uninstallsingleoptsharedlib

uninstallsingleoptsharedgeneral:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project AUXHOME=Ravl VAR=opt SHARED_LIB_POSTFIX=/shared/single SHAREDBUILD=1 uninstall recurse
#       Seperate versions of the uninstall generals exist to allow for differing
#       manifests dependant on VAR, SHAREDBUILD, etc.

uninstallsingleoptsharedlib:
	@if [ -h $(ABS_DESTDIR)$(libdir)/libRavl$(STAMP_SINGLE_EXT) ] || [ -f $(ABS_DESTDIR)$(libdir)/libRavl$(STAMP_SINGLE_EXT) ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl$(STAMP_SINGLE_EXT) ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl$(STAMP_SINGLE_EXT) ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi
ifeq ($(STAMP_SINGLE),VER)
	@if [ -h $(ABS_DESTDIR)$(libdir)/libRavl.so.$(PROJECT_MAJOR) ] || [ -f $(ABS_DESTDIR)$(libdir)/libRavl.so.$(PROJECT_MAJOR) ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl.so.$(PROJECT_MAJOR) ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl.so.$(PROJECT_MAJOR) ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi
endif
ifneq ($(STAMP_SINGLE),NO)
	@if [ -h $(ABS_DESTDIR)$(libdir)/libRavl.so ] || [ -f $(ABS_DESTDIR)$(libdir)/libRavl.so ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl.so ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl.so ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi
endif
#        Removal of libRavl$(STAMP_SINGLE_EXT) will alway remove the actual
#        library file. If we are version stamping the single library, we will
#        then need to remove the symbolic links from the lesser qualified names



.DEFAULT: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) $@

#JFi:ToDo Targets for clean ctags distclean distcheck html install-check
#                     install-html install-pdf installdirs mostlyclean
#                     maintainter-clean pdf tags


.PHONY: check debug debugshared default dist doc fullsrc \
 gprof gprofbin gprofshared gprofsharedbin install install-strip \
 install-stripProject installDummyDefs installHdrs installopt installoptlib \
 installoptshared installoptsharedgeneral installoptsharedlib installProject \
 installpkgconf installQMake installRavl.def installsingleopt \
 installsingleoptlib installsingleoptshared installsingleoptsharedgeneral \
 installsingleoptsharedlib LocalQMake opt optbin optshared optsharedbin \
 pkgconf qmake QMake Ravl.def recheck retest retestgprof retestgprofshared \
 retestopt retestoptshared retestsinglegprof retestsinglegprofshared \
 retestsingleopt retestsingleoptshared rpm SetRootInstalled SetRootStaged \
 singledebug singledebugbin singledebugshared singledebugsharedbin singlegprof \
 singlegprofbin singlegprofshared singlegprofsharedbin singleopt singleoptbin \
 singleoptshared singleoptsharedbin singleSetRootInstalled singleSetRootStaged \
 singlesharedSetRootInstalled singlesharedSetRootStaged test testgprof \
 testgprofshared testopt testoptshared testsinglegprof testsinglegprofshared \
 testsingleopt testsingleoptshared uninstall uninstallDummyDefs uninstallHdrs \
 uninstallopt uninstalloptgeneral uninstalloptlib uninstalloptshared \
 uninstalloptsharedgeneral uninstalloptsharedlib uninstallpkgconf \
 uninstallQMake uninstallRavl.def uninstallsingleopt uninstallsingleoptgeneral \
 uninstallsingleoptlib uninstallsingleoptshared \
 uninstallsingleoptsharedgeneral uninstallsingleoptsharedlib .DEFAULT

