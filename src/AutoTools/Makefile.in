# @configure_input@
# This file is part of RAVL, Recognition And Vision Library
# Copyright (C) 2011-14, University of Surrey
# This code may be redistributed under the terms of the GNU General
# Public License (GPL). See the gpl.licence file for details or
# see http://www.gnu.org/copyleft/gpl.html

SOURCEHOME=@abs_srcdir@/src

PROJECT_OUT=@abs_builddir@

WORKING_QMAKE_DATA=@WORKING_QMAKE_DATA@
WORKING_QMAKE_BIN=@WORKING_QMAKE_BIN@

# Ensure any DESTDIR is an absolute path
ifdef DESTDIR
  ABS_DESTDIR=$(abspath $(DESTDIR))

  # Propogate absolute path going forward
  SET_DESTDIR=DESTDIR=$(ABS_DESTDIR)
endif

# Include QMake global definitions
include @QMAKE_CONFIGFILES@/Config.QMake

# Include project specific definitions
include $(PROJECT_OUT)/Config.Project

# Include project specific installation targets
include $(PROJECT_OUT)/Targets.Project

# RAVL Makefile and default flags for QMake and RAVL itself

RAVL_MAKEFILE=$(WORKING_QMAKE_DATA)/Makefiles/QMake.mk

RAVL_FLAGS=BASEINSTALL=1 FULLBUILDSRC='BASE_VAR=none' CONFIGFILE=$(PROJECT_OUT)/Config.Project INCLUDEDIR=$(PROJECT_OUT)/include 

# Trace commands if QMAKE_INFO is in use
ifndef QMAKE_INFO
SHOWIT=@
else
SHOWIT=
endif

# Control version stamping of single-shared library
ifndef STAMP_SINGLE
 ifdef LIB_STAMP
  STAMP_SINGLE=$(LIB_STAMP)
 else
  STAMP_SINGLE=VER
  # Default to full version stamping
 endif
endif

ifeq ($(STAMP_SINGLE),VER)
 STAMP_SINGLE_EXT=.$(SHAREDEXT).$(PROJECT_VERSION)
else
 ifeq ($(STAMP_SINGLE),NO)
  # Version stamping switched off
  STAMP_SINGLE_EXT=.$(SHAREDEXT)
 else
  STAMP_SINGLE_EXT=.$(SHAREDEXT).$(PROJECT_MAJOR)
 endif
endif

# Additional files to manually copy into a distribution
#
# These need manual specification as they do not always appear in the
# SOURCES/HEADERS definitions as they are included dependant on RESOURCES
#
DIST_ADDITIONS=src/GUI/3D/gdkgl.c src/GUI/3D/gtkglarea.c src/GUI/3D/gdkgl.h src/GUI/3D/gtkglarea.h

# Builds

default: qmake fullsrc singleoptsharedbin pkgconf

check: testsingleoptshared 

debug: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=debug NOEXEBUILD=1 libbuild

debugshared: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=debug SHAREDBUILD=1 NOEXEBUILD=1 libbuild

debugsharedobj: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=debug SHAREDBUILD=1 NOEXEBUILD=1 LINK_PLIB=0 libbuild

dist:
	$(MAKE) -C @abs_srcdir@ -f $(WORKING_QMAKE_DATA)/Makefiles/Dist.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project DIST_ADDITIONS="$(DIST_ADDITIONS)" dist

doc: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/.. -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) LLP="LD_LIBRARY_PATH=$(PROJECT_OUT)/lib/$(ARC)/opt/shared/single:$$LD_LIBRARY_PATH" fulldoc
	cp $(PROJECT_OUT)/share/QMake/Support/Help.txt $(PROJECT_OUT)/share/doc/Ravl/html/Help.txt
#       We currently start from above the src directory ($SOURCEHOME)/..) in
#       order to pick up the documentation from QMake. This is because there is
#       currently no framework to link to documentation from another project.
#       This means we cannot produce the QMake documentation from within that
#       seperate project and link to that from the Ravl documentation. We
#       therefore have to treat the QMake documentation as if it was part Ravl,
#       hence the start point.
#
#       Final step copies across the QMake help file; this is again due to there
#       being no existing mechanism to link to documentation in an external
#       project.

fullsrc: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) NOCHECKOUT=1 fullsrc

gprof: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=gprof NOEXEBUILD=1 libbuild

gprofbin: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) fullgprof

gprofshared: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=gprof SHAREDBUILD=1 NOEXEBUILD=1 libbuild

gprofsharedobj: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=gprof SHAREDBUILD=1 NOEXEBUILD=1 LINK_PLIB=0 libbuild

gprofsharedbin: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) SHAREDBUILD=1 fullgprof

install: installQMake installProject

installProject: installsingleoptshared installHdrs installpkgconf installRavlDefs

install-strip:
	$(MAKE) STRIP_SWITCH="-s" install

install-stripProject:
	$(MAKE) STRIP_SWITCH="-s" installProject


# Dot Def file installation.
#
# In order to allow existing client projects to easily switch to using the
# single library, Ravl has to install both the dot def file associated with
# the single library and the dot def files associated with all of the Ravl
# "multi" libraries; even if not installing the "multi" libs themselves .
installRavlDefs: installRavl.def installRavlMultiDefs

installRavlMultiDefs:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=debug SHAREDBUILD=1 STRIP_SWITCH=$(STRIP_SWITCH) PROJECT_DIR=Ravl insDefs recurse

installRavl.def: $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/Ravl.def

$(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/Ravl.def: $(PROJECT_OUT)/lib/libdep/4install/Ravl.def $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep
	$(INSTALL) $(PROJECT_OUT)/lib/libdep/4install/Ravl.def $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/Ravl.def

$(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep:
	$(SHOWIT)$(MKDIR_P) $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep
 
$(PROJECT_OUT)/lib/libdep/4install/Ravl.def: $(PROJECT_OUT)/lib/libdep/4install/Ravl.def.in
	$(SHOWIT)$(SED) -e 's![@]PROJECT_LIBDIR[@]!$(libdir)!g' \
                        -e 's![@]PROJECT_INCDIR[@]!$(includedir)!g' \
                        $(PROJECT_OUT)/lib/libdep/4install/Ravl.def.in > $(PROJECT_OUT)/lib/libdep/4install/Ravl.def
# The installed copy of Ravl.def needs to know the actual values for $libdir
# and $includedir. Hence we only finalise the file when we perform the install. 


# All the install targets recurse down the source directories using the defs.mk
# files to determine what needs installing. The relevant files are then
# installed from their built location in the build tree.

installdebuglib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=debug SetRootInstalled
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=debug STRIP_SWITCH=$(STRIP_SWITCH) insLibs recurse
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=debug SetRootStaged
#       First re-link those modules that need to be built with the location of
#       the library reflected in the code. 
#       Use QMake to install the libraries (this will automatically install the
#       libraries to the $(DESTDIR)$(libdir)/debug/$(libdir) directory.
#       Finally re-build the relevant objects/libraries with the original path
#       to the staging area.

installdebugsharedlib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=debug SHAREDBUILD=1 SetRootInstalled
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=debug SHAREDBUILD=1 STRIP_SWITCH=$(STRIP_SWITCH) insLibs recurse
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=debug SHAREDBUILD=1 SetRootStaged
#       First re-link those modules that need to be built with the location of
#       the library reflected in the code. 
#       Use QMake to install the libraries (this will automatically install the
#       libraries to the $(DESTDIR)$(libdir)/debug/$(libdir) directory.
#       Finally re-build the relevant objects/libraries with the original path
#       to the staging area.

installHdrs:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project insHdrs recurse

installopt:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt SetRootInstalled
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile optbin
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) install recurse
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) insLibs recurse
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) insMustLinks recurse
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt SetRootStaged
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile optbin
#       First re-link those modules that need to be built with the location of
#       the library reflected in the code. 
#       Re-make the binaries to pick up the path changes
#       Use the 'install' function of QMake to install the Ravl utility
#       binaries; config files; data files and scripts. 
#       Install the libraries via the QMake insLibs and the MUSTLINK files via
#       the QMake insMustLinks target.
#       Restore the embedded paths to point to the staged location of Ravl
#       Rebuild the binaries to pick up the path resotoration
#       N.B. This recepie includes a duplication of parts of the installoptlib
#       recepie (we can not use the XXXgeneral XXXlib form used by the shared
#       recepies because of the need to rebuild the binaries to pick up the
#       change in resource-root). Please remember to apply any changes to the
#       other copy of the code as appropriate.

installoptlib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt SetRootInstalled
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) insLibs recurse
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) insMustLinks recurse
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt SetRootStaged
#       First re-link those modules that need to be built with the location of
#       the library reflected in the code. Install the libraries, then the
#       MUSTLINK objects via QMake and finally re-build the relevant objects
#       and libraries with the original path to the staging area.
#       N.B. Parts of this recepie are duplicated in the installopt recepie (we
#       can not use the XXXgeneral XXXlib form used by the shared recepies
#       because of the need to rebuild the binaries to pick up the change in
#       resource-root). Please remember to apply any changes to the other copy
#       of the code as appropriate.

installoptshared: installoptsharedgeneral installoptsharedlib

installoptsharedgeneral:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SHAREDBUILD=1 STRIP_SWITCH=$(STRIP_SWITCH) install recurse
#       Use the 'install' function of QMake to install the Ravl utility
#       binaries; config files; data files and scripts. 

installoptsharedlib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt SHAREDBUILD=1 SetRootInstalled
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SHAREDBUILD=1 STRIP_SWITCH=$(STRIP_SWITCH) insLibs recurse
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SHAREDBUILD=1 STRIP_SWITCH=$(STRIP_SWITCH) insMustLinks recurse
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt SHAREDBUILD=1 SetRootStaged
#       First re-link those modules that need to be built with the location of
#       the library reflected in the code. Install the libraries via QMake and
#       then the MUSTLINK objects (the MUSTLINKs are not strictly necessary
#       for the shared library, but may be needed for old client projects that
#       have existing .def files that still include the MUSTLINKs regardless of
#       if a build is shared or not). Finally, re-build the relevant objects
#       and libraries with the original path to the staging area.

installpkgconf: $(ABS_DESTDIR)$(libdir)/pkgconfig $(ABS_DESTDIR)$(libdir)/pkgconfig/Ravl.pc

$(ABS_DESTDIR)$(libdir)/pkgconfig:
	$(SHOWIT)$(MKDIR_P) $(ABS_DESTDIR)$(libdir)/pkgconfig

$(ABS_DESTDIR)$(libdir)/pkgconfig/Ravl.pc: $(PROJECT_OUT)/lib/pkgconfig/4install/Ravl.pc
	$(INSTALL_DATA) $(PROJECT_OUT)/lib/pkgconfig/4install/Ravl.pc $(ABS_DESTDIR)$(libdir)/pkgconfig/Ravl.pc

$ $(PROJECT_OUT)/lib/pkgconfig/4install/Ravl.pc: $ $(PROJECT_OUT)/lib/pkgconfig/4install/Ravl.pc.in
	$(SHOWIT)$(SED) -e 's![@]PROJECT_PREFIX[@]!$(prefix)!g' \
                        -e 's![@]PROJECT_DATAROOTDIR[@]!$(datarootdir)!g' \
                        -e 's![@]PROJECT_DATADIR[@]!$(datadir)!g' \
                        -e 's![@]PROJECT_SYSCONFDIR[@]!$(sysconfdir)!g' \
                        -e 's![@]PROJECT_INCDIR[@]!$(includedir)!g' \
                        -e 's![@]PROJECT_LIBDIR[@]!$(libdir))!g' \
                        $(PROJECT_OUT)/lib/pkgconfig/4install/Ravl.pc.in > $(PROJECT_OUT)/lib/pkgconfig/4install/Ravl.pc
# The installed copy of Ravl.pc needs to know the actual values for $libdir
# and $prefix, etc. Hence we only finalise the file when we perform the install. 

installsingledebuglib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=debug LINK_PLIB=0 singleSetRootInstalled
	$(SHOWIT)if [ ! -d $(ABS_DESTDIR)$(libdir)/debug$(libdir) ] ; then $(MKDIR_P) $(ABS_DESTDIR)$(libdir)/debug$(libdir) ; fi
	$(INSTALL) $(STRIP_SWITCH) $(PROJECT_OUT)/lib/$(ARC)/debug/single/libRavl.a $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.a
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=debug LINK_PLIB=0 singleSetRootStaged
#       First rebuild those modules that rely on the installation path and
#       relink their libraries. 
#       Ensure the target dir exists and manually copy across the single library
#       (debug libraries are installed under the same path as the non-debug
#       version but prefixed by any $(DESTDIR) and $(libdir)/debug).
#       Finally, we restore the local path into the object and library files.

installsingledebugsharedlib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=debug SHAREDBUILD=1 LINK_PLIB=0 singlesharedSetRootInstalled
	$(SHOWIT)if [ ! -d $(ABS_DESTDIR)$(libdir)/debug$(libdir) ] ; then $(MKDIR_P) $(ABS_DESTDIR)$(libdir)/debug$(libdir) ; fi
	$(INSTALL) $(STRIP_SWITCH) $(PROJECT_OUT)/lib/$(ARC)/debug/shared/single/libRavl$(STAMP_SINGLE_EXT) $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl$(STAMP_SINGLE_EXT)
ifeq ($(STAMP_SINGLE),VER)
	$(SHOWIT)if [ -h $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ] || [ -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ] ; \
                 then \
                    $(RM) $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ; \
                 fi ; \
                 cd $(ABS_DESTDIR)$(libdir)/debug$(libdir); $(LN_S) libRavl$(STAMP_SINGLE_EXT) libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ; \
                 fi
endif
ifneq ($(STAMP_SINGLE),NO)
	$(SHOWIT)if [ -h $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT) ] || [ -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT) ] ; \
                 then \
                    $(RM) $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT) ; \
                 fi ; \
                 cd $(ABS_DESTDIR)$(libdir)/debug$(libdir); $(LN_S) libRavl$(STAMP_SINGLE_EXT) libRavl.$(SHAREDEXT) ; \
                 fi
endif
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=debug SHAREDBUILD=1 LINK_PLIB=0 singlesharedSetRootStaged
#       First re-build the relevant modules that use the location of the library
#       as an embedded path and relink the library.
#       Ensure the target dir exists (debug libraries are installed under
#       the same path as the non-debug version but prefixed by any $(DESTDIR)
#       and $(libdir)/debug).
#       Rather than call the insLibs make target, we manually install the
#       library and set up the symbolic links for the less-quantified library
#       names.
#       Finally, we restore the local path into the object/library files.

installsingleopt:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt LINK_PLIB=0 singleSetRootInstalled
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile singleoptbin
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SHARED_LIB_POSTFIX=/single STRIP_SWITCH=$(STRIP_SWITCH) install recurse
	$(SHOWIT)if [ ! -d $(ABS_DESTDIR)$(libdir) ] ; then $(MKDIR_P) $(ABS_DESTDIR)$(libdir) ; fi
	$(INSTALL) $(STRIP_SWITCH) $(PROJECT_OUT)/lib/$(ARC)/opt/single/libRavl.a $(ABS_DESTDIR)$(libdir)/libRavl.a
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) insMustLinks recurse
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt LINK_PLIB=0 singleSetRootStaged
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile singleoptbin
#       First rebuild those modules that rely on the installation path and
#       relink their libraries. 
#       When this is complete, the binaries are rebuilt to pick up the path
#       changes.
#       We can then use the 'install' function of QMake to install these
#       binaries along with the Ravl config files; data files and scripts. We
#       must set SHARED_LIB_POSTFIX (to /single) in order to force QMake to use
#       the version of the binaries compiled against the single shared Ravl
#       library rather than the more usual (for QMake) individual shared
#       libraries. 
#       Rather than call the insLibs make target, we manually copy across the
#       single library having first ensured the target directory exists.
#       We then install the MUSTLINK files.
#       Finally, we restore the local path into the object and library files
#       and then remake the binaries to pick up the restore.
#       N.B. This recepie includes a duplication of parts of the recepie for
#       installsingleoptlib (we can not use the XXXgeneral XXXlib form used by
#       the shared recepies because of the need to rebuild the binaries to pick
#       up the change in resource-root). Please remember to apply any changes
#       to the other copy of the code as appropriate.

installsingleoptlib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt LINK_PLIB=0 singleSetRootInstalled
	$(SHOWIT)if [ ! -d $(ABS_DESTDIR)$(libdir) ] ; then $(MKDIR_P) $(ABS_DESTDIR)$(libdir) ; fi
	$(INSTALL) $(STRIP_SWITCH) $(PROJECT_OUT)/lib/$(ARC)/opt/single/libRavl.a $(ABS_DESTDIR)$(libdir)/libRavl.a
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) insMustLinks recurse
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt LINK_PLIB=0 singleSetRootStaged
#       First rebuild those modules that rely on the installation path and
#       relink their libraries. 
#       Ensure the target dir exists and manually copy across the library.
#       We then install the MUSTLINK files.
#       Finally, we restore the local path into the object and library files.
#       N.B. Parts of this recepie are duplicated in the installsingleopt
#       recepie (we can not use the XXXgeneral XXXlib form used by the shared
#       recepies because of the need to rebuild the binaries to pick up the
#       change in resource-root). Please remember to apply any changes to the
#       other copy of the code as appropriate.

installsingleoptshared:installsingleoptsharedgeneral installsingleoptsharedlib

installsingleoptsharedgeneral:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SUMMARIES=Ravl SHAREDBUILD=1 STRIP_SWITCH=$(STRIP_SWITCH) install recurse
#       Use the 'install' function of QMake to install the Ravl utility
#       binaries; config files; data files and scripts. Setting SUMMARIES to
#       Ravl forces QMake to use the version of the binaries compiled against
#       the single shared Ravl library rather than the more usual (for QMake)
#       individual shared libraries. 

installsingleoptsharedlib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt SHAREDBUILD=1 LINK_PLIB=0 singlesharedSetRootInstalled
	$(SHOWIT)if [ ! -d $(ABS_DESTDIR)$(libdir) ] ; then $(MKDIR_P) $(ABS_DESTDIR)$(libdir) ; fi
	$(INSTALL) $(STRIP_SWITCH) $(PROJECT_OUT)/lib/$(ARC)/opt/shared/single/libRavl$(STAMP_SINGLE_EXT) $(ABS_DESTDIR)$(libdir)/libRavl$(STAMP_SINGLE_EXT)
ifeq ($(STAMP_SINGLE),VER)
	$(SHOWIT)if [ -h $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ] || [ -f $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ] ; \
                 then \
                    $(RM) $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ; \
                 fi ; \
                 cd $(ABS_DESTDIR)$(libdir); $(LN_S) libRavl$(STAMP_SINGLE_EXT) libRavl.$(SHAREDEXT).$(PROJECT_MAJOR)
endif
ifneq ($(STAMP_SINGLE),NO)
	$(SHOWIT)if [ -h $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT) ] || [ -f $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT) ] ; \
                 then \
                    $(RM) $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT) ; \
                 fi ; \
                 cd $(ABS_DESTDIR)$(libdir); $(LN_S) libRavl$(STAMP_SINGLE_EXT) libRavl.$(SHAREDEXT)
endif
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) insMustLinks recurse
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -f $(PROJECT_OUT)/Makefile VAR=opt SHAREDBUILD=1 LINK_PLIB=0 singlesharedSetRootStaged
#       First rebuild those modules that rely on the installation path and
#       relink their libraries and the single library itself. 
#       Then ensure the target directory exists and manually copy across the
#       single shared library. 
#       If required, we set up the symbolic links for the less-quantified
#       library names.
#       We then install the MUSTLINK files. These are not strictly necessary
#       for the shared library, but may be needed for old client projects
#       that have existing .def files that still include the MUSTLINKs
#       regardless of if a build is shared or not.
#       Finally, we restore the local path into the object/library files.


installQMake:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -f @abs_builddir@/QMake/Makefile STAGING=@abs_builddir@/QMake STRIP_SWITCH=$(STRIP_SWITCH) install

opt: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt NOEXEBUILD=1 libbuild

optbin: opt
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) fullopt

optshared: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt SHAREDBUILD=1 NOEXEBUILD=1 libbuild

optsharedobj: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt SHAREDBUILD=1 NOEXEBUILD=1 LINK_PLIB=0 libbuild

optsharedbin: optshared
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) SHAREDBUILD=1 fullopt

pkgconf: 
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Single -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) NOCHECKOUT=1 MAKEPKGCONFIG=1 fullsrc

qmake: @NeededQMake@
#       Will equate to "LocalQMake QMake" unless we already have an installed
#       QMake when only a new copy for installation (QMake) will be needed.

QMake:
	$(MAKE) -f @abs_builddir@/QMake/Makefile STAGING=@abs_builddir@/QMake
#       Stage, under @abs_builddir@/QMake, a version of QMake ready for a
#       standard install (one that will run when the makefiles are installed
#       under $(datadir)/QMake/Makefiles).

LocalQMake: 
	$(MAKE) -f @abs_builddir@/QMake/Makefile \
                   prefix=@abs_builddir@ STAGING=@abs_builddir@/transient/QMake
	$(MAKE) -f @abs_builddir@/QMake/Makefile  prefix=@abs_builddir@ \
                   STAGING=@abs_builddir@/transient/QMake install
#       Install a copy of QMake under the Ravl build directory in a form that
#       will run from that directory.
#       To achieve this, we have to build QMake into a staging directory and
#       then install that.


recheck: retest

retest: retestsingleoptshared 

retestgprof:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=gprof TEST_TARGET=gprof retest

retestgprofshared:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=gprof SHAREDBUILD=1 TEST_TARGET=gprofshared retest

retestopt:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt TEST_TARGET=opt retest

retestoptshared:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt SHAREDBUILD=1 TEST_TARGET=optshared retest

retestsinglegprof:
	@cd $(PROJECT_OUT)/test/gprof/single/bin; ls > ../TestExes
	cd $(PROJECT_OUT)/test/gprof/single && \
           PATH=$(PROJECT_OUT)/test/gprof/single/bin:$(PROJECT_OUT)/bin/utils/gprof/single/bin:$$PATH \
           $(PROJECT_OUT)/bin/utils/gprof/single/bin/Validate -v $(PROJECT_OUT)/test/gprof/single
	
retestsinglegprofshared:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=gprof SHAREDBUILD=1 SUMMARIES=Ravl TEST_TARGET=optshared retest
	
retestsingleopt:
	@cd $(PROJECT_OUT)/test/opt/single/bin; ls > ../TestExes
	cd $(PROJECT_OUT)/test/opt/single && \
           PATH=$(PROJECT_OUT)/test/opt/single/bin:$(PROJECT_OUT)/bin/utils/opt/single/bin:$$PATH \
           $(PROJECT_OUT)/bin/utils/opt/single/bin/Validate -v $(PROJECT_OUT)/test/opt/single
	
retestsingleoptshared:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt SHAREDBUILD=1 SUMMARIES=Ravl TEST_TARGET=optshared retest
	
#JFi:Only start of RPM process implemented. Should automate everything or drop.
rpm: qmake 
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) rpmbuild 

SetRootInstalled:
	$(SHOWIT)$(WORKING_QMAKE_BIN)/untouch -f $(SOURCEHOME)/Core/Base/Resource.cc
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Core/Base \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=$(VAR) NOEXEBUILD=1 \
                $(if $(SHAREDBUILD),SHAREDBUILD=$(SHAREDBUILD)) \
                $(if $(LINK_PLIB),LINK_PLIB=$(LINK_PLIB)) \
                CCFLAGS="$(CCFLAGS) -DDEFAULT_ROOT=\\\"$(patsubst %/share,%,$(datadir))\\\"" \
                libbuild
	$(SHOWIT)$(WORKING_QMAKE_BIN)/untouch -f $(SOURCEHOME)/Contrib/Gnome/Gnome.cc
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Contrib/Gnome \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=$(VAR) NOEXEBUILD=1 \
                $(if $(SHAREDBUILD),SHAREDBUILD=$(SHAREDBUILD)) \
                $(if $(LINK_PLIB),LINK_PLIB=$(LINK_PLIB)) \
                CCFLAGS="$(CCFLAGS) -DPREFIX=\\\"$(prefix)\\\" -DDATADIR=\\\"$(datadir)/Ravl\\\" -DSYSCONFDIR=\\\"$(sysconfdir)/Ravl\\\" -DLIBDIR=\\\"$(libdir)\\\"" \
                libbuild

SetRootStaged:
	$(SHOWIT)$(WORKING_QMAKE_BIN)/untouch -f $(SOURCEHOME)/Core/Base/Resource.cc
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Core/Base \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=$(VAR) NOEXEBUILD=1 \
                $(if $(SHAREDBUILD),SHAREDBUILD=$(SHAREDBUILD)) \
                $(if $(LINK_PLIB),LINK_PLIB=$(LINK_PLIB)) \
                libbuild
	$(SHOWIT)$(WORKING_QMAKE_BIN)/untouch -f $(SOURCEHOME)/Contrib/Gnome/Gnome.cc
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Contrib/Gnome \
                -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=$(VAR) NOEXEBUILD=1 \
                $(if $(SHAREDBUILD),SHAREDBUILD=$(SHAREDBUILD)) \
                $(if $(LINK_PLIB),LINK_PLIB=$(LINK_PLIB)) \
                libbuild

singledebug: debug
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Projects/Ravl/Makefiles/SingleLib.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=debug makedirs buildstatic

singledebugbin: singledebug debugbin
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Projects/Ravl/Makefiles/Recursive.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=debug SINGLELIB=1 programs recurse

singledebugshared: debugsharedobj
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Single -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=debug SHAREDBUILD=1 LIB_STAMP=$(STAMP_SINGLE) NOEXEBUILD=1 LINK_PLIB=0 libbuild

singledebugsharedbin:singledebugshared
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=debug SHAREDBUILD=1 SUMMARIES=Ravl exebuild

singlegprof: gprof
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Projects/Ravl/Makefiles/SingleLib.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=gprof makedirs buildstatic

singlegprofbin: singlegprof gprofbin
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Projects/Ravl/Makefiles/Recursive.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=gprof SINGLELIB=1 programs recurse

singlegprofshared: gprofsharedobj
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Single -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=gprof SHAREDBUILD=1 LIB_STAMP=$(STAMP_SINGLE) NOEXEBUILD=1 LINK_PLIB=0 libbuild

singlegprofsharedbin: singlegprofshared
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=gprof SHAREDBUILD=1 SUMMARIES=Ravl exebuild

singleopt: opt
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Projects/Ravl/Makefiles/SingleLib.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt makedirs buildstatic

singleoptbin: singleopt optbin
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Projects/Ravl/Makefiles/Recursive.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SINGLELIB=1 programs recurse

singleoptshared: optsharedobj
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Single -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt SHAREDBUILD=1 LIB_STAMP=$(STAMP_SINGLE) NOEXEBUILD=1 LINK_PLIB=0 libbuild

singleoptsharedbin: singleoptshared
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt SHAREDBUILD=1 SUMMARIES=Ravl exebuild

singleSetRootInstalled: SetRootInstalled
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Projects/Ravl/Makefiles/SingleLib.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project makedirs buildstatic

singleSetRootStaged: SetRootStaged
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Projects/Ravl/Makefiles/SingleLib.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project makedirs buildstatic

singlesharedSetRootInstalled: SetRootInstalled
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Single -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) LIB_STAMP=$(STAMP_SINGLE) LINK_PLIB=0 NOEXEBUILD=1 libbuild

singlesharedSetRootStaged: SetRootStaged
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Single -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) LIB_STAMP=$(STAMP_SINGLE) LINK_PLIB=0 NOEXEBUILD=1 libbuild

test: testsingleoptshared 

testgprof:
	@$(RM) -f $(PROJECT_OUT)/test/gprof/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=gprof TEST_TARGET=gprof test

testgprofshared:
	@$(RM) -f $(PROJECT_OUT)/test/gprof/shared/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=gprof SHAREDBUILD=1 TEST_TARGET=gprofshared test

testopt:
	@$(RM) -f $(PROJECT_OUT)/test/opt/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt TEST_TARGET=opt test

testoptshared:
	@$(RM) -f $(PROJECT_OUT)/test/opt/shared/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt SHAREDBUILD=1 TEST_TARGET=optshared test

testsinglegprof:
	@$(RM) -f $(PROJECT_OUT)/test/gprof/single/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Projects/Ravl/Makefiles/Recursive.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=gprof SINGLELIB=1 test recurse
	@cd $(PROJECT_OUT)/test/gprof/single/bin; ls > ../TestExes
	cd $(PROJECT_OUT)/test/gprof/single && \
           PATH=$(PROJECT_OUT)/test/gprof/single/bin:$(PROJECT_OUT)/bin/utils/gprof/single/bin:$$PATH \
           $(PROJECT_OUT)/bin/utils/gprof/single/bin/Validate -v $(PROJECT_OUT)/test/gprof/single

testsinglegprofshared:
	@$(RM) -f $(PROJECT_OUT)/test/gprof/shared/single.Ravl/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=gprof SHAREDBUILD=1 SUMMARIES=Ravl TEST_TARGET=optshared test

testsingleopt:
	@$(RM) -f $(PROJECT_OUT)/test/opt/single/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Projects/Ravl/Makefiles/Recursive.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SINGLELIB=1 test recurse
	@cd $(PROJECT_OUT)/test/opt/single/bin; ls > ../TestExes
	cd $(PROJECT_OUT)/test/opt/single && \
           PATH=$(PROJECT_OUT)/test/opt/single/bin:$(PROJECT_OUT)/bin/utils/opt/single/bin:$$PATH \
           $(PROJECT_OUT)/bin/utils/opt/single/bin/Validate -v $(PROJECT_OUT)/test/opt/single
	
testsingleoptshared:
	@$(RM) -f $(PROJECT_OUT)/test/opt/shared/single.Ravl/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt SHAREDBUILD=1 SUMMARIES=Ravl TEST_TARGET=optshared test

uninstall: uninstallQMake uninstallsingleoptshared uninstallHdrs uninstallMustLinks uninstallpkgconf uninstallRavlDefs

uninstalldebuglib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=debug uinsLibs recurse

uninstalldebugsharedlib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=debug SHAREDBUILD=1 uinsLibs recurse

uninstallHdrs:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project uinsHdrs recurse

uninstallMustLinks:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) uinsMustLinks recurse

uninstallopt: uninstalloptgeneral uninstalloptlib

uninstalloptgeneral:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt uninstall recurse
#       Seperate versions of the uninstall generals exist to allow for differing
#       manifests dependant on VAR, SHAREDBUILD, etc.

uninstalloptlib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt STRIP_SWITCH=$(STRIP_SWITCH) uinsLibs recurse

uninstalloptshared: uninstalloptsharedgeneral uninstalloptsharedlib

uninstalloptsharedgeneral:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SHAREDBUILD=1 uninstall recurse
#       Seperate versions of the uninstall generals exist to allow for differing
#       manifests dependant on VAR, SHAREDBUILD, etc.

uninstalloptsharedlib:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SHAREDBUILD=1 STRIP_SWITCH=$(STRIP_SWITCH) uinsLibs recurse

uninstallpkgconf: 
	@if [ -f $(ABS_DESTDIR)$(libdir)/pkgconfig/Ravl.pc ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/pkgconfig/Ravl.pc ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/pkgconfig/Ravl.pc ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi

uninstallQMake:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -f @abs_builddir@/QMake/Makefile uninstall

uninstallRavlDefs: uninstallRavlMultiDefs uninstallRavl.def

uninstallRavlMultiDefs:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=debug SHAREDBUILD=1 STRIP_SWITCH=$(STRIP_SWITCH) PROJECT_DIR=Ravl uinsDefs recurse

uninstallRavl.def:
	@if [ -f $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/Ravl.def ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/Ravl.def ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/Ravl.def ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi

uninstallsingledebuglib:
	@if [ -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.a ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.a ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.a ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi

uninstallsingledebugsharedlib:
	@if [ -h $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl$(STAMP_SINGLE_EXT) ] || [ -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl$(STAMP_SINGLE_EXT) ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl$(STAMP_SINGLE_EXT) ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl$(STAMP_SINGLE_EXT) ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi
ifeq ($(STAMP_SINGLE),VER)
	@if [ -h $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ] || [ -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi
endif
ifneq ($(STAMP_SINGLE),NO)
	@if [ -h $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT) ] || [ -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT) ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT) ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/debug$(libdir)/libRavl.$(SHAREDEXT) ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi
endif
#        Removal of libRavl$(STAMP_SINGLE_EXT) will alway remove the actual
#        library file. If we are version stamping the single library, we will
#        then need to remove the symbolic links from the lesser qualified names

uninstallsingleopt:uninstallsingleoptgeneral uninstallsingleoptlib

uninstallsingleoptgeneral: 
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt uninstall recurse
#       Seperate versions of the uninstall generals exist to allow for differing
#       manifests dependant on VAR, SHAREDBUILD, etc.

uninstallsingleoptlib:
	@if [ -f $(ABS_DESTDIR)$(libdir)/libRavl.a ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl.a ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl.a ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi

uninstallsingleoptshared: uninstallsingleoptsharedgeneral  uninstallsingleoptsharedlib

uninstallsingleoptsharedgeneral:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE_DATA)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SHARED_LIB_POSTFIX=/shared/single SHAREDBUILD=1 uninstall recurse
#       Seperate versions of the uninstall generals exist to allow for differing
#       manifests dependant on VAR, SHAREDBUILD, etc.

uninstallsingleoptsharedlib:
	@if [ -h $(ABS_DESTDIR)$(libdir)/libRavl$(STAMP_SINGLE_EXT) ] || [ -f $(ABS_DESTDIR)$(libdir)/libRavl$(STAMP_SINGLE_EXT) ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl$(STAMP_SINGLE_EXT) ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl$(STAMP_SINGLE_EXT) ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi
ifeq ($(STAMP_SINGLE),VER)
	@if [ -h $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ] || [ -f $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT).$(PROJECT_MAJOR) ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi
endif
ifneq ($(STAMP_SINGLE),NO)
	@if [ -h $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT) ] || [ -f $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT) ] ; \
         then \
            if [ X$(QMAKE_INFO) != X ] ;\
            then \
               echo $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT) ; \
            fi ;\
            $(RM) -f $(ABS_DESTDIR)$(libdir)/libRavl.$(SHAREDEXT) ; \
            RET=$$? ; \
            if [ $$RET -ne 0 ] ; \
            then \
               exit $$RET ;\
            fi ;\
         fi
endif
#        Removal of libRavl$(STAMP_SINGLE_EXT) will alway remove the actual
#        library file. If we are version stamping the single library, we will
#        then need to remove the symbolic links from the lesser qualified names



.DEFAULT: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) $@

#JFi:ToDo Targets for clean ctags distclean distcheck html install-check
#                     install-html install-pdf installdirs mostlyclean
#                     maintainter-clean pdf tags


.PHONY: check debug debugshared debugsharedobj default dist doc fullsrc \
 gprof gprofbin gprofshared gprofsharedobj gprofsharedbin install \
 install-strip install-stripProject installdebuglib installdebugsharedlib \
 installHdrs installopt installoptlib installoptshared installoptsharedgeneral \
 installoptsharedlib installProject installpkgconf installQMake \
 installRavlDefs installRavlMultiDefs installsingledebuglib \
 installsingledebugsharedlib installsingleopt installsingleoptlib \
 installsingleoptshared installsingleoptsharedgeneral \
 installsingleoptsharedlib LocalQMake opt optbin optshared optsharedobj \
 optsharedbin pkgconf qmake QMake recheck retest retestgprof retestgprofshared \
 retestopt retestoptshared retestsinglegprof retestsinglegprofshared \
 retestsingleopt retestsingleoptshared rpm SetRootInstalled SetRootStaged \
 singledebug singledebugbin singledebugshared singledebugsharedbin singlegprof \
 singlegprofbin singlegprofshared singlegprofsharedbin singleopt singleoptbin \
 singleoptshared singleoptsharedbin singleSetRootInstalled singleSetRootStaged \
 singlesharedSetRootInstalled singlesharedSetRootStaged test testgprof \
 testgprofshared testopt testoptshared testsinglegprof testsinglegprofshared \
 testsingleopt testsingleoptshared uninstall uninstalldebuglib \
 uninstalldebugsharedlib uninstallHdrs uninstallMustLinks uninstallopt \
 uninstalloptgeneral uninstalloptlib uninstalloptshared \
 uninstalloptsharedgeneral uninstalloptsharedlib uninstallpkgconf \
 uninstallQMake uninstallRavl.def uninstallRavlDefs uninstallRavlMultiDefs \
 uninstallsingledebuglib uninstallsingledebugsharedlib uninstallsingleopt \
 uninstallsingleoptgeneral uninstallsingleoptlib uninstallsingleoptshared \
 uninstallsingleoptsharedgeneral uninstallsingleoptsharedlib .DEFAULT

