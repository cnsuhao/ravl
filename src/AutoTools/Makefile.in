# @configure_input@
# This file is part of RAVL, Recognition And Vision Library
# Copyright (C) 2011-12, University of Surrey
# This code may be redistributed under the terms of the GNU General
# Public License (GPL). See the gpl.licence file for details or
# see http://www.gnu.org/copyleft/gpl.html

SOURCEHOME=@abs_top_srcdir@/src

PROJECT_OUT=@abs_top_builddir@

WORKING_QMAKE=@WORKING_QMAKE@

# Ensure any DESTDIR is an absolute path
ifdef DESTDIR
  ABS_DESTDIR=$(abspath $(DESTDIR))

  # Propogate absolute path going forward
  SET_DESTDIR=DESTDIR=$(ABS_DESTDIR)
endif

# Include QMake global definitions
include @QMAKE_CONFIGFILES@/Config.QMake

# Include project specific definitions
include $(PROJECT_OUT)/Config.Project

# Include project specific installation targets
include $(PROJECT_OUT)/Targets.Project

# RAVL Makefile and default flags for QMake and RAVL itself

RAVL_MAKEFILE=$(WORKING_QMAKE)/Makefiles/QMake.mk

RAVL_FLAGS=BASEINSTALL=1 FULLBUILDSRC='BASE_VAR=none' CONFIGFILE=$(PROJECT_OUT)/Config.Project INCLUDEDIR=$(PROJECT_OUT)/include 

# Trace commands if QMAKE_INFO is in use
ifndef QMAKE_INFO
SHOWIT=@
else
SHOWIT=
endif

# Builds

default: qmake fullsrc opt optshared optbin singleoptshared singleoptsharedbin pkgconf Ravl.def
#JFi:To Do- make doc (and support from configure i.e. locate tools)

check: testsingleoptshared 

debug: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=debug NOEXEBUILD=1 libbuild

debugshared: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=debug SHAREDBUILD=1 NOEXEBUILD=1 libbuild

distdir: rpm

doc: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/.. -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) PROJECT_NAME=Ravl PROJECT_DESC="RAVL, Recognition And Vision Library" fulldoc
	cp $(PROJECT_OUT)/share/QMake/Support/Help.txt $(PROJECT_OUT)/share/doc/Ravl/html/Help.txt
# We currently start from above the src directory ($SOURCEHOME)/..) in order
# to pick up the documentation from QMake. This is because there is currently
# no framework to link to documentation from another project. This means we
# cannot produce the QMake documentation from within that seperate project
# and link to that from the Ravl documentation. We therefore have to treat the
# QMake documentation as if it was part Ravl, hence the start point.
#
# PROJECT_NAME setting is to force the examples and other html files into the
# correct directory. This is required because Ravl currently does not use
# PACKAGE and PROJECT_NAME in the designed way for QMake. Ravl currently will
# use a PACKAGE setting of Ravl/pkg rather than setting PROJECT_NAME to Ravl
# and setting PACKAGE to pkg. This cannot currently be changed until ccmath
# is moved out of the Ravl source tree and used as a seperate external library.
#
# Final step copies across the QMake help file; this is again due to there being
# no existing mechanism to link to documentation in an external project.

fullsrc: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) NOCHECKOUT=1 fullsrc

install: installQMake installsingleoptshared installHdrs installpkgconf installRavl.def installDummyDefs

BUILT_DOT_DEFS=$(filter-out Ravl.def, $(patsubst $(PROJECT_OUT)/lib/libdep/%,%,$(wildcard $(PROJECT_OUT)/lib/libdep/*)))
# List of .def files created by build process (minus the single library's
# Ravl.def). Listed as simple filename-only form.

DUMMY_DOT_DEFS=$(patsubst %,$(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/%, $(BUILT_DOT_DEFS))
# List of dummy .def files we should install (listed with installation target
# path).

define installddd
  $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/$1: $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep
	@echo \# Dummy Dot Def file >  $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/$1
endef

$(foreach dotdef,$(BUILT_DOT_DEFS),$(eval $(call installddd,$(dotdef))))
 
installDummyDefs: $(DUMMY_DOT_DEFS)



# All the install targets recurse down the source directories using the defs.mk
# files to determine what needs installing. The relevant files are then
# installed from their built location in the build tree.

installHdrs:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project insHdrs recurse

installoptshared:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project AUXHOME=Ravl VAR=opt SHAREDBUILD=1 install recurse
	$(SHOWIT)touch $(SOURCEHOME)/Core/Base/Resource.cc
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Core/Base -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) CCFLAGS="$(CCFLAGS) -DDEFAULT_ROOT=\\\"$(datadir)/Ravl\\\"" VAR=opt SHAREDBUILD=1 NOEXEBUILD=1 libbuild
	$(SHOWIT)touch $(SOURCEHOME)/Contrib/Gnome/Gnome.cc
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Contrib/Gnome -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) CCFLAGS="$(CCFLAGS) -DPREFIX=\\\"$(prefix)\\\" -DDATADIR=\\\"$(datadir)/Ravl\\\" -DSYSCONFDIR=\\\"$(sysconfdir)/Ravl\\\" -DLIBDIR=\\\"$(libdir)\\\"" VAR=opt SHAREDBUILD=1 NOEXEBUILD=1 libbuild
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SHAREDBUILD=1 insLibs recurse
	$(SHOWIT)touch $(SOURCEHOME)/Core/Base/Resource.cc
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Core/Base -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt SHAREDBUILD=1 NOEXEBUILD=1 libbuild
	$(SHOWIT)touch $(SOURCEHOME)/Contrib/Gnome/Gnome.cc
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Contrib/Gnome -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt SHAREDBUILD=1 NOEXEBUILD=1 libbuild
# Use the 'install' function of QMake to install the Ravl utility binaries;
# config files; data files and scripts. Then re-link those modules that need
# to be built with the location of the library reflected in the code. Install
# the libraries via QMake and re-build the relevant objects/libraries with
# the original path to the staging area

installpkgconf: $(ABS_DESTDIR)$(libdir)/pkgconfig $(ABS_DESTDIR)$(libdir)/pkgconfig/Ravl.pc

$(ABS_DESTDIR)$(libdir)/pkgconfig:
	$(SHOWIT)$(MKDIR_P) $(ABS_DESTDIR)$(libdir)/pkgconfig:

$(ABS_DESTDIR)$(libdir)/pkgconfig/Ravl.pc:
	$(INSTALL_DATA) $(PROJECT_OUT)/lib/pkgconfig/Ravl.pc $(ABS_DESTDIR)$(libdir)/pkgconfig/Ravl.pc

installRavl.def:  $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep
	$(INSTALL) $(PROJECT_OUT)/lib/libdep/Ravl.def $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep/Ravl.def

$(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep:
	$(SHOWIT)$(MKDIR_P) $(ABS_DESTDIR)$(datadir)/QMake/Projects/Ravl/libdep

installsingleoptshared:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Makefiles/Install.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project AUXHOME=Ravl VAR=opt SHARED_LIB_POSTFIX=/shared/single SHAREDBUILD=1 install recurse
	$(SHOWIT)if [ ! -d $(ABS_DESTDIR)$(libdir) ] ; then $(MKDIR_P) $(ABS_DESTDIR)$(libdir) ; fi
	$(SHOWIT)touch $(SOURCEHOME)/Core/Base/Resource.cc
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Core/Base -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) CCFLAGS="$(CCFLAGS) -DDEFAULT_ROOT=\\\"$(datadir)/Ravl\\\"" VAR=opt SHAREDBUILD=1 NOEXEBUILD=1 libbuild
	$(SHOWIT)touch $(SOURCEHOME)/Contrib/Gnome/Gnome.cc
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Contrib/Gnome -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) CCFLAGS="$(CCFLAGS) -DPREFIX=\\\"$(prefix)\\\" -DDATADIR=\\\"$(datadir)/Ravl\\\" -DSYSCONFDIR=\\\"$(sysconfdir)/Ravl\\\" -DLIBDIR=\\\"$(libdir)\\\"" VAR=opt SHAREDBUILD=1 NOEXEBUILD=1 libbuild
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/SingleLib.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SHAREDBUILD=1 makedirs buildshared
	$(INSTALL) $(PROJECT_OUT)/lib/$(ARC)/opt/shared/single/libRavl.so $(ABS_DESTDIR)$(libdir)/libRavl.so
	$(SHOWIT)touch $(SOURCEHOME)/Core/Base/Resource.cc
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Core/Base -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt SHAREDBUILD=1 NOEXEBUILD=1 libbuild
	$(SHOWIT)touch $(SOURCEHOME)/Contrib/Gnome/Gnome.cc
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Contrib/Gnome -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt SHAREDBUILD=1 NOEXEBUILD=1 libbuild
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/SingleLib.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SHAREDBUILD=1 makedirs buildshared
# Use the 'install' function of QMake to install the Ravl utility binaries;
# config files; data files and scripts. We must set SHARED_LIB_POSTFIX
# (to /shared/single) in order to force QMake to use the version of the
# binaries compiled against the single shared Ravl library rather than the
# more usual (for QMake) individual shared libraries. 
# Then turn attention to the library itself. First ensure the target dir
# exists then re-build the relevant modules that use the installed path and
# relink the library before installing it. Rather than call the insLibs make
# target, we manually copy across the single shared library. Finally, 
# restore the local path into the object/library files

installQMake:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) $(SET_DESTDIR) -f @abs_top_builddir@/QMake/Makefile STAGING=@abs_top_builddir@/QMake install

opt: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt NOEXEBUILD=1 libbuild

optbin: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) fullopt

optshared: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt SHAREDBUILD=1 NOEXEBUILD=1 libbuild

pkgconf: $(PROJECT_OUT)/lib/pkgconfig $(PROJECT_OUT)/lib/pkgconfig/Ravl.pc

$(PROJECT_OUT)/lib/pkgconfig:
	$(SHOWIT) $(MKDIR_P) $@

$(PROJECT_OUT)/lib/pkgconfig/Ravl.pc:
	$(SHOWIT)echo prefix=$(prefix) > $@
	$(SHOWIT)echo datarootdir=$(datarootdir) >> $@
	$(SHOWIT)echo datadir=$(datadir) >> $@
	$(SHOWIT)echo sysconfdir=$(sysconfdir) >> $@
	$(SHOWIT)echo libdir=$(libdir) >> $@
	$(SHOWIT)echo >> $@
	$(SHOWIT)echo Name: Ravl >> $@
	$(SHOWIT)echo Version: @PACKAGE_VERSION@ >> $@
	$(SHOWIT)echo Description: Recognition And Vision Library with modules for Computer Vision, Pattern Recognition and much more >> $@
	$(SHOWIT)echo URL: @PACKAGE_URL@ >> $@
	$(SHOWIT)echo >> $@
	$(SHOWIT)echo Libs:-L\${libdir} -lRavl >> $@
	$(SHOWIT)echo Libs.private:$(ALL_EXTERNAL_LIBS)>> $@
	$(SHOWIT)echo Cflags:-I\${includedir}>> $@
	$(SHOWIT)echo >> $@

qmake: @NeededQMake@
# Will equate to "LocalQMake QMake" unless we already have an installed
# QMake when only a new copy for installation (QMake) will be needed.

QMake:
	$(MAKE) -f @abs_top_builddir@/QMake/Makefile STAGING=@abs_top_builddir@/QMake
# Stage, under @abs_top_builddir@/QMake, a version of QMake ready for a
# standard install (one that will run when the makefiles are installed
# under $(datadir)/QMake/Makefiles).

LocalQMake: 
	$(MAKE) -f @abs_top_builddir@/QMake/Makefile DESTDIR=staged bindir=@abs_top_builddir@/share/QMake/bin \
                         datadir=@abs_top_builddir@/share sysconfdir=@abs_top_builddir@ STAGING=@abs_top_builddir@/share/QMake
	$(SHOWIT)if [ ! -f @abs_top_builddir@/share/QMake/bin/Validate ]; \
                 then \
                   if [ ! -h @abs_top_builddir@/share/QMake/bin/Validate ]; \
                   then \
                     cd @abs_top_builddir@/share/QMake/bin; \
                     $(LN_S) @abs_top_builddir@/bin/Validate Validate; \
                   fi \
                 fi
# Stage QMake under the Ravl build directory in a form that will run from
# that directory. To achieve this, we have to set the destination for both
# the staging and install targets to be the same for the makefiles. The
# install target for the makefiles uses $(datadir)/QMake/Makefiles as its
# destination, while the staging target uses $(STAGING)/Makefiles; hence the
# slightly different values for those two variables. DESTDIR=staged prevents
# make complaining about using identical destinations for both the staged and
# install targets. As we are only staging and not performing an install,
# DESTDIR will have no other effect and gives us the functionality we are
# looking for. As well as $(datadir), $(sysconfdir) automatically has /QMake
# suffixed to it for the install process, hence the value of $(sysconfdir) 
# that is used here. The final symbolic link allows the local QMake to find
# Validate that, while it should be part of QMake, is currently part of RAVL.
# This last stage is a bit of a bodge as it won't work on platforms that do
# not support symbolic links (as the target doesn't actually exist at this
# point). The proper solution is to uncouple Validate from RAVL (re-write
# it) and move it into QMake.


Ravl.def: $(PROJECT_OUT)/lib/libdep $(PROJECT_OUT)/lib/libdep/Ravl.def

$(PROJECT_OUT)/lib/libdep:
	$(SHOWIT) $(MKDIR_P) $@

$(PROJECT_OUT)/lib/libdep/Ravl.def: $(PROJECT_OUT)/Makefile
	$(SHOWIT)echo \# This file is part of RAVL, Recognition And Vision Library > $@
	$(SHOWIT)echo \# Copyright \(C\) 2001-12,  University of Surrey. >> $@
	$(SHOWIT)echo \# This code may be redistributed under the terms of the GNU Lesser >> $@
	$(SHOWIT)echo \# General Public License \(LGPL\). See the lgpl.licence file for details or >> $@
	$(SHOWIT)echo \# see http://www.gnu.org/copyleft/lesser.html >> $@
	$(SHOWIT)echo \# file-header-ends-here >> $@
	$(SHOWIT)echo >> $@
	$(SHOWIT)echo ifndef RAVL_DEF >> $@
	$(SHOWIT)echo >> $@
	$(SHOWIT)echo "  RAVL_DEF=1" >> $@
	$(SHOWIT)echo >> $@
	$(SHOWIT)echo "  ifndef RAVL_LIBS" >> $@
	$(SHOWIT)echo "    RAVL_LIBS=-L$(libdir) -lRavl $(ALL_EXTERNAL_LIBS)" >> $@
	$(SHOWIT)echo "  endif" >> $@
	$(SHOWIT)echo >> $@
	$(SHOWIT)echo "  EXELIB := \$$(RAVL_LIBS) \$$(EXELIB)" >> $@
	$(SHOWIT)echo >> $@
	$(SHOWIT)echo "  ifndef RAVL_CFLAGS" >> $@
	$(SHOWIT)echo "    RAVL_CFLAGS=-I$(includedir) $(ALL_EXTERNAL_CFLAGS)" >> $@
	$(SHOWIT)echo "  endif" >> $@
	$(SHOWIT)echo >> $@
	$(SHOWIT)echo "  INCLUDES += \$$(RAVL_CFLAGS)" >> $@
	$(SHOWIT)echo >> $@
	$(SHOWIT)echo endif >> $@
	$(SHOWIT)echo >> $@


retestopt:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt TEST_TARGET=opt retest

retestsingleopt:
	@cd $(PROJECT_OUT)/test/opt/single/bin; ls > ../TestExes
	cd $(PROJECT_OUT)/test/opt/single && \
           PATH=$(PROJECT_OUT)/test/opt/single/bin:$(PROJECT_OUT)/bin/utils/opt/single/bin:$$PATH \
           $(PROJECT_OUT)/bin/utils/opt/bin/Validate -v $(PROJECT_OUT)/test/opt/single
	
retestoptshared:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt SHAREDBUILD=1 TEST_TARGET=optshared retest
	
retestsingleoptshared:
	@cd $(PROJECT_OUT)/test/opt/shared/single/bin; ls > ../TestExes
	cd $(PROJECT_OUT)/test/opt/shared/single && \
           PATH=$(PROJECT_OUT)/test/opt/shared/single/bin:$(PROJECT_OUT)/bin/utils/opt/shared/single/bin:$$PATH \
           LD_LIBRARY_PATH=$(PROJECT_OUT)/lib/$(ARC)/opt/shared/single:$$LD_LIBRARY_PATH \
           $(PROJECT_OUT)/bin/utils/opt/bin/Validate -v $(PROJECT_OUT)/test/opt/shared/single
	
#JFi:Only start of RPM process implemented. Should automate everything or drop.
rpm: qmake 
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) rpmbuild 

singleopt:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/SingleLib.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt makedirs buildstatic

singleoptbin:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/Recursive.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SINGLELIB=1 programs recurse

singleoptshared:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/SingleLib.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SHAREDBUILD=1 makedirs buildshared

singleoptsharedbin:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/Recursive.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SINGLELIB=1 SHAREDBUILD=1 programs recurse

singledebug:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/SingleLib.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=debug makedirs buildstatic

singledebugbin:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/Recursive.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=debug SINGLELIB=1 programs recurse

singledebugshared:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/SingleLib.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=debug SHAREDBUILD=1 makedirs buildshared

singledebugsharedbin:
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/Recursive.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=debug SINGLELIB=1 SHAREDBUILD=1 programs recurse

testopt:
	@$(RM) -f $(PROJECT_OUT)/test/opt/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt TEST_TARGET=opt test

testsingleopt:
	@$(RM) -f $(PROJECT_OUT)/test/opt/single/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/Recursive.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SINGLELIB=1 test recurse
	@cd $(PROJECT_OUT)/test/opt/single/bin; ls > ../TestExes
	cd $(PROJECT_OUT)/test/opt/single && \
           PATH=$(PROJECT_OUT)/test/opt/single/bin:$(PROJECT_OUT)/bin/utils/opt/single/bin:$$PATH \
           $(PROJECT_OUT)/bin/utils/opt/bin/Validate -v $(PROJECT_OUT)/test/opt/single
	
testoptshared:
	@$(RM) -f $(PROJECT_OUT)/test/opt/shared/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt SHAREDBUILD=1 TEST_TARGET=optshared test

testsingleoptshared:
	@$(RM) -f $(PROJECT_OUT)/test/opt/shared/single/bin/*
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/Recursive.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt SINGLELIB=1 SHAREDBUILD=1 test recurse
	@cd $(PROJECT_OUT)/test/opt/shared/single/bin; ls > ../TestExes
	cd $(PROJECT_OUT)/test/opt/shared/single && \
           PATH=$(PROJECT_OUT)/test/opt/shared/single/bin:$(PROJECT_OUT)/bin/utils/opt/shared/single/bin:$$PATH \
           LD_LIBRARY_PATH=$(PROJECT_OUT)/lib/$(ARC)/opt/shared/single:$$LD_LIBRARY_PATH \
           $(PROJECT_OUT)/bin/utils/opt/bin/Validate -v $(PROJECT_OUT)/test/opt/shared/single

.DEFAULT: qmake
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) $@

#JFi:ToDo Targets for install-strip install-check uninstall clean 
#    dist distcheck html pdf install-html install-pdf installdirs distclean
#    mostlyclean maintainter-clean tags ctags


.PHONY: check debug debugshared default distdir doc fullsrc install \
 installHdrs installoptshared installpkgconf installQMake \
 installsingleoptshared LocalQMake opt optbin optshared pkgconf qmake QMake \
 recurse retestopt retestoptshared retestsingleopt retestsingleoptshared \
 rpm singleopt singleoptbin singleoptshared singleoptsharedbin singledebug \
 singledebugbin singledebugshared singledebugsharedbin testopt testoptshared \
 testsingleopt testsingleoptshared .DEFAULT

SetRootInstalledOptStatic:
	touch $(SOURCEHOME)/Core/Base/Resource.cc
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Core/Base -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) CCFLAGS="$(CCFLAGS) -DDEFAULT_ROOT=\\\"$(datadir)/Ravl\\\"" VAR=opt NOEXEBUILD=1 libbuild
	touch $(SOURCEHOME)/Contrib/Gnome/Gnome.cc
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Contrib/Gnome -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) CCFLAGS="$(CCFLAGS) -DPREFIX=\\\"$(prefix)\\\" -DDATADIR=\\\"$(datadir)/Ravl\\\" -DSYSCONFDIR=\\\"$(sysconfdir)/Ravl\\\" -DLIBDIR=\\\"$(libdir)\\\"" VAR=opt NOEXEBUILD=1 libbuild
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/SingleLib.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt makedirs buildstatic

SetRootStagedOptStatic:
	touch $(SOURCEHOME)/Core/Base/Resource.cc
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Core/Base -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt NOEXEBUILD=1 libbuild
	touch $(SOURCEHOME)/Contrib/Gnome/Gnome.cc
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME)/Contrib/Gnome -f $(RAVL_MAKEFILE) $(RAVL_FLAGS) VAR=opt NOEXEBUILD=1 libbuild
	$(MAKE) $(PKG_MAKEFLAGS) $(CONFIG_MAKEFLAGS) -C $(SOURCEHOME) -f $(WORKING_QMAKE)/Projects/Ravl/Makefiles/SingleLib.mk CONFIGFILE=$(PROJECT_OUT)/Config.Project VAR=opt makedirs buildstatic



